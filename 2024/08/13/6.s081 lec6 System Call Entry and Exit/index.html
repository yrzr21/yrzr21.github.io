<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="lec6 System Call Entry and Exit" />
    <meta name="hexo-theme-A4" content="v1.9.2" />
    <link rel="alternate icon" type="image/webp" href="/img/logo.jpg">
    <title>Toki</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.2.0"></head>
    
    
        <style>
            .index-main{
                max-width:  880px;
            }
        </style>

    
    



    

    
    

    
    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #e4e4e4 ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/logo.jpg" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Toki</a> 
            <span class="description">Why so serious?</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
            
                <li><a href="/contact/">联系</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        
            
                <div class="post-main-title">
                    lec6 System Call Entry and Exit
                </div>
            
        
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%AF%BE%E5%89%8D%E5%87%86%E5%A4%87"><span class="post-toc-text">课前准备</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#RISC-V-trap-machinery"><span class="post-toc-text">RISC-V trap machinery</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="post-toc-text">最重要的寄存器概述</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%BC%BA%E5%88%B6%E8%A7%A6%E5%8F%91-trap-%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="post-toc-text">强制触发 trap 的硬件操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Traps-from-user-space"><span class="post-toc-text">Traps from user space</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#uservec"><span class="post-toc-text">uservec</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#usertrap"><span class="post-toc-text">usertrap</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#usertrapret"><span class="post-toc-text">usertrapret</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#userret"><span class="post-toc-text">userret</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Code-Calling-system-calls"><span class="post-toc-text">Code: Calling system calls</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Code-System-call-arguments"><span class="post-toc-text">Code: System call arguments</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0"><span class="post-toc-text">指针参数</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Traps-from-kernel-space"><span class="post-toc-text">Traps from kernel space</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#kernelvec%EF%BC%9A%E8%BF%9B%E5%85%A5"><span class="post-toc-text">kernelvec：进入</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#kerneltrap%EF%BC%9A%E8%BF%9B%E5%85%A5"><span class="post-toc-text">kerneltrap：进入</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD"><span class="post-toc-text">定时器中断</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#kerneltrap%EF%BC%9A%E8%BF%94%E5%9B%9E"><span class="post-toc-text">kerneltrap：返回</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#kernelvec%EF%BC%9A%E8%BF%94%E5%9B%9E"><span class="post-toc-text">kernelvec：返回</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#usertrap%EF%BC%9A%E9%98%B2%E6%AD%A2%E8%AE%BE%E5%A4%87%E4%B8%AD%E6%96%AD"><span class="post-toc-text">usertrap：防止设备中断</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Real-World"><span class="post-toc-text">Real World</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Trap-%E6%9C%BA%E5%88%B6"><span class="post-toc-text">Trap 机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Supervisor-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="post-toc-text">Supervisor 寄存器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%89%B9%E6%9D%83%E6%A8%A1%E5%BC%8F%E4%B8%8D%E7%89%B9%E6%9D%83"><span class="post-toc-text">特权模式不特权</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4-trap"><span class="post-toc-text">用户空间 trap</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7%E4%B8%8E%E9%80%8F%E6%98%8E"><span class="post-toc-text">隔离性与透明</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Trap%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="post-toc-text">Trap代码执行流程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ECALL-%E4%B9%8B%E5%89%8D%E7%9A%84%E7%8A%B6%E6%80%81"><span class="post-toc-text">ECALL 之前的状态</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#write"><span class="post-toc-text">write</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%AD%A4%E6%97%B6%E7%9A%84%E9%A1%B5%E8%A1%A8"><span class="post-toc-text">此时的页表</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ECALL%E6%8C%87%E4%BB%A4%E4%B9%8B%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81"><span class="post-toc-text">ECALL指令之后的状态</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ecall"><span class="post-toc-text">ecall</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="post-toc-text">页表</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5"><span class="post-toc-text">接下来</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ecall%E4%B8%8D%E8%AE%A9%E7%A1%AC%E4%BB%B6%E6%9B%BF%E6%88%91%E4%BB%AC%E5%AE%8C%E6%88%90%E8%BF%99%E4%BA%9B%E4%BA%8B%EF%BC%9F"><span class="post-toc-text">为什么ecall不让硬件替我们完成这些事？</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#uservec%E5%87%BD%E6%95%B0"><span class="post-toc-text">uservec函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E5%AF%84%E5%AD%98%E5%99%A8"><span class="post-toc-text">保存用户寄存器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%86%E5%A4%87%E5%86%85%E6%A0%B8%E7%8E%AF%E5%A2%83%EF%BC%9A%E6%A0%88%E5%92%8C%E9%A1%B5%E8%A1%A8"><span class="post-toc-text">准备内核环境：栈和页表</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#usertrap%E5%87%BD%E6%95%B0"><span class="post-toc-text">usertrap函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#usertrapret%E5%87%BD%E6%95%B0"><span class="post-toc-text">usertrapret函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#userret%E5%87%BD%E6%95%B0"><span class="post-toc-text">userret函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93"><span class="post-toc-text">总结</span></a></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="https://jsd.cdn.zzko.cn/npm/hexo-theme-a4@latest/source/css/lightgallery.min.css"><div class=".article-gallery"><p>System Call Entry &#x2F; Exit</p>
<h3 id="课前准备"><a href="#课前准备" class="headerlink" title="课前准备"></a>课前准备</h3><blockquote>
<p>Chapter4: Traps and system calls</p>
</blockquote>
<p>有三种事件会导致 CPU 暂停普通指令的执行，并强制将 <em>控制转移</em> 到处理该事件的特殊代码上：系统调用 <em>system call</em>。用户程序通过 ecall 请求系统服务；异常 <em>exception</em>。一条指令执行了非法操作时引发（无论用户程序还是内核）；设备中断 <em>interrupt</em>。设备发出信号表示需要处理。</p>
<blockquote>
<p>本书使用 <em>trap</em> 作为这些情况的统称</p>
</blockquote>
<p>通常来说，trap 发生并处理前后，程序不应意识到有任何特殊情况发生，也就是说， <em>trap 对程序应该是透明的</em></p>
<blockquote>
<p>这一点对于中断尤其重要</p>
</blockquote>
<p>通常来说，<em>trap 发生前后的流程</em> 是：trap 强制转移控制权给内核；内核保存寄存器和其他状态；内核执行 trap 的处理代码；内核恢复保存的状态并从 trap 中返回；原始代码继续执行</p>
<blockquote>
<p>由 xv6 <em>内核处理所有的 trap</em>。这对于系统调用来说是自然而然的。对于中断来说也是合理的，因为隔离要求用户进程不能直接使用设备，而且只有内核拥有处理设备所需的状态。对于异常也是合理的，因为 xv6 会通过终止发生异常的程序来响应所有用户空间的异常。</p>
</blockquote>
<p><em>trap 处理</em> 分为四个阶段：CPU 执行一些硬件操作；一段 assembly “vector” 为C代码准备环境；C trap handler；系统调用或设备驱动服务例程。</p>
<p>尽管发生 trap 时可以执行单一的代码处理所有 trap，但分别为用户空间、内核空间、定时器中断设置独立的汇编向量和 C trap 处理程序会更加方便。</p>
<h4 id="RISC-V-trap-machinery"><a href="#RISC-V-trap-machinery" class="headerlink" title="RISC-V trap machinery"></a>RISC-V trap machinery</h4><blockquote>
<p>kernel&#x2F;riscv.h:1</p>
</blockquote>
<p>每个 RISC-V CPU 都有一组 <em>控制寄存器</em>，内核可以通过写入这些寄存器来告知 CPU 如何处理 trap，同时内核也可以读取这些寄存器以了解发生的 trap。</p>
<h5 id="最重要的寄存器概述"><a href="#最重要的寄存器概述" class="headerlink" title="最重要的寄存器概述"></a>最重要的寄存器概述</h5><ol>
<li><em>stvec</em>：Supervisor Trap Vector，内核将其 trap handler 的地址写入这里；RISC-V 在发生 trap 时会跳转到此地址来处理。</li>
<li><em>sepc</em>：Supervisor Exception Program Counter，保存发生异常时的 PC 值。<ul>
<li>因为 PC 随后会被 stvec 的值覆盖</li>
<li><em>sret</em>（从 trap 返回）指令会将 sepc 的值复制到 PC。内核可以通过 <em>写入 sepc 来控制 sret 返回的位置</em>。</li>
</ul>
</li>
<li><em>scause</em>：Supervisor Cause，RISC-V 在此寄存器中存放一个数字，用于描述 trap 的原因。</li>
<li><em>sscratch</em>：Supervisor Scratch，内核在此寄存器中存放一个值，该值在 trap 处理程序的最开始处很有用。</li>
<li><em>sstatus</em>：Supervisor Status<ul>
<li>Supervisor Interrupt Enable：<em>SIE</em> 位控制是否启用设备中断。如果内核清除了 SIE，RISC-V 将推迟设备中断，直到内核设置 SIE。</li>
<li>Supervisor Previous Privilege：<em>SPP</em> 位指示 trap 是来自用户模式还是主管模式，并控制 sret 返回到哪个模式。</li>
</ul>
</li>
</ol>
<p>以上寄存器与 <em>内核模式下处理的异常</em> 相关，用户模式下无法读写这些寄存器</p>
<p>这些寄存器在机器模式下也有相应的版本，用于处理机器模式下的 trap；xv6 <em>仅在处理定时器中断</em> 的特殊情况下使用它们。</p>
<p><em>多核芯片</em>的每一个 CPU 都有自己的一套这些寄存器，可以在同一时间处理不同的 trap。</p>
<h5 id="强制触发-trap-的硬件操作"><a href="#强制触发-trap-的硬件操作" class="headerlink" title="强制触发 trap 的硬件操作"></a>强制触发 trap 的硬件操作</h5><p>当需要强制触发 trap 时，<em>RISC-V 硬件</em> 对所有 trap 类型（除定时器中断外）执行以下操作：</p>
<ol>
<li>若是设备中断，检查 sstatus 的 SIE 位，若被清除则不执行以下操作：</li>
<li>清除 SIE，避免被中断</li>
<li>复制 PC 到 sepc</li>
<li>保存操作模式 到 sstaus 的 SPP</li>
<li>设置 scause 反映 trap 原因</li>
<li>切换为内核模式</li>
<li>复制 stec 到 PC</li>
<li>从新PC开始执行</li>
</ol>
<p>CPU 在处理 trap 时 <em>不会切换到内核页表、不会切换到内核中的堆栈，也不会保存除 PC 以外的任何寄存器。</em> 这些操作由内核软件执行。CPU 在 trap 期间执行的工作量最小，目的是为软件提供灵活性。</p>
<blockquote>
<p>你可能会想，CPU 的 trap 处理序列是否可以进一步简化。例如，假设 CPU 不切换程序计数器，那么 trap 可能会在切换到主管模式时仍然执行用户指令。这些用户指令可能会破坏用户&#x2F;内核隔离，例如通过修改 <code>satp</code> 寄存器指向允许访问所有物理内存的页表。因此，CPU 切换到内核指定的指令地址（即 <code>stvec</code>）是很重要的。</p>
</blockquote>
<h4 id="Traps-from-user-space"><a href="#Traps-from-user-space" class="headerlink" title="Traps from user space"></a>Traps from user space</h4><p>这种情况可能发生在：用户程序使用 syscall、非法操作、设备中断</p>
<p>其代码逻辑是：uservec（kernel&#x2F;trampoline.S） -&gt; usertrap（kernel&#x2F;trap.c）-&gt; 内核，返回时的路径为：内核 -&gt; usertrapret（kernel&#x2F;trap.c）-&gt; userret（kernel&#x2F;trampoline.S）</p>
<blockquote>
<p>来自用户代码的 trap 比来自内核的 trap 更具挑战性，因为 satp 指向一个不映射内核的<em>用户页表</em>，而且堆栈指针可能包含<em>无效或甚至恶意的值</em>。</p>
</blockquote>
<p>由于 RISC-V 硬件在 trap 期间不会切换页表，<em>用户页表必须包含对 uservec 地址的映射</em>，这是 stvec 指向的 trap 向量指令。<em>由 uservec 设置 satp，切换到内核页表</em>；为了在切换后继续执行指令，<em>uservec 必须在内核页表和用户页表中映射到相同的地址。</em></p>
<p>这个包含 uservec的页叫做 <em>trampoline</em>，xv6 在内核页表和每个用户页表中将 trampoline 页面映射到相同的虚拟地址。trampoline 的内容在 trampoline.S 中设置，<em>而在执行用户代码时，stvec 被设置为 uservec</em>。</p>
<h5 id="uservec"><a href="#uservec" class="headerlink" title="uservec"></a>uservec</h5><p>uservec 开始执行时 <em>并没有可用的寄存器和数据</em>，所有 Unprivileged 寄存器放的都是用户的数据。</p>
<p>RISC-V 提供了 <em>sscratch</em> 寄存器和 <em>csrrw</em> 指令。csrrw 将 a0 的值与 sscratch 交换，从而保存a0，提供可用的寄存器：a0，<em>并给我们传递了一个指针放到 a0 中</em>，它指向本进程的 <em>trapframe</em>，预先保存到 sscratch 中</p>
<p>下一个任务是保存用户寄存器，这通过 trapframe 实现。<em>uservec 将所有用户寄存器保存到 trapframe 中</em>。此时我们仍处在用户地址空间，<em>所以需要对 trapframe 进行映射</em> 。创建进程时，kernel 为 trapframe 分配一个页，放在TRAMPOLINE的正下方：TRAPFRAME。进程的 p-&gt;trapframe 指向 trapframe 的是物理地址，以便内核可以通过内核页表使用它。</p>
<blockquote>
<p>trapframe 包含指向当前进程的内核堆栈、当前 CPU 的 hartid、usertrap 的地址以及内核页表地址的指针</p>
</blockquote>
<p>uservec 于是可以设置 satp，切换到内核页表。最后，调用 usertrap</p>
<h5 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h5><p>usertrap 根据 trapframe 中的内容确定 trap 的原因，处理，并返回。</p>
<blockquote>
<p>kernel&#x2F;trap.c:37</p>
</blockquote>
<ol>
<li>它首先更改 stvec。以便 kernelvec 处理</li>
<li>然后保存 sepc。因为在 usertrap中可能会发生进程切换，从而导致 sepc 被覆盖</li>
<li>如果 trap 原因是 syscall，那么函数 syscall 会处理它；若是设备中断，则会调用 devintr；否则为异常，内核会杀死出错的进程<ul>
<li>在系统调用路径上，保存的用户 pc 会增加 4 —— RISC-V 会将程序计数器指向 ecall 指令</li>
</ul>
</li>
</ol>
<h5 id="usertrapret"><a href="#usertrapret" class="headerlink" title="usertrapret"></a>usertrapret</h5><p>在返回用户空间的过程中，第一步是调用 usertrapret。这个函数设置 RISC-V 控制寄存器，为将来来自用户空间的 trap 做准备。</p>
<p>这包括：</p>
<ol>
<li>设置 stvec 指向 uservec</li>
<li>设置 uservec 依赖的 trapframe 字段</li>
<li>设置 sepc 为先前保存的 pc</li>
<li>设置 a0 为用户页表</li>
</ol>
<p>最后调用 trampoline 上的 userret，userret 准备用户数据并使得程序返回到用户空间</p>
<h5 id="userret"><a href="#userret" class="headerlink" title="userret"></a>userret</h5><p>userret 根据 a0 切换到用户页表，然后设置 a0 为 TRAPFRAME</p>
<blockquote>
<p>请注意，用户页表只映射了 trampoline 页面和 TRAPFRAME，但没有映射其他内核内容。同样，trampoline 页面在用户和内核页表中映射到相同的虚拟地址，这使得 uservec 在更改 satp 后能够继续执行。</p>
</blockquote>
<p>userret 将 trapframe 中的 a0 放到 sscratch 中，再恢复除了a0外的所有寄存器。然后交换 a0（此时存放TRAPFRAME）和 sscratch，成功恢复所有用户寄存器。</p>
<p>最后调用 sret 返回到用户空间</p>
<h4 id="Code-Calling-system-calls"><a href="#Code-Calling-system-calls" class="headerlink" title="Code: Calling system calls"></a>Code: Calling system calls</h4><p>让我们看看 initcode.S 如何一路调用到 exec 的：</p>
<p>代码将 exec 的参数放到 a0 和 a1 中，并将系统调用号放到 a7 中，然后调用 ecall。ecall 触发进入内核，并依次执行 uservec、usertrap、syscall。syscall 根据系统调用号调用相应的函数。函数返回时，syscall 将返回值放到 p-&gt;trapframe-&gt;a0</p>
<h4 id="Code-System-call-arguments"><a href="#Code-System-call-arguments" class="headerlink" title="Code: System call arguments"></a>Code: System call arguments</h4><p>用户按照调用约定将参数放到固定的位置，uservec 将其放到 trapframe中，经过 usertrap、syscall，调用相关的系统调用函数。</p>
<p>系统调用函数使用函数 argint、argaddr 和 argfd 通过调用 argraw，获取 trapframe 中的第 n 个系统调用参数。</p>
<h5 id="指针参数"><a href="#指针参数" class="headerlink" title="指针参数"></a>指针参数</h5><p>用户有时候会传递指针给内核让内核读写自己的内存，但由于无效或恶意的指针、页表不同的原因，这一过程无法用正常的方式进行，<em>必须使用专门的函数读写用户提供的指针指向的内存</em></p>
<p>如 <em>fetchstr</em>，它调用 <em>copyinstr</em> 完成这项工作：</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240812185923.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240812185923.png" class title="Pasted image 20240812185923.png"></a>

<p>copyinstr 使用 walkaddr 模拟 mmu，通过用户提供的页表和虚拟地址，获取实际的物理地址，并将其复制到指定的容器中</p>
<blockquote>
<p>walkaddr 会检查用户提供的虚拟地址是否属于该进程</p>
</blockquote>
<p>类似的函数有：copyout</p>
<h4 id="Traps-from-kernel-space"><a href="#Traps-from-kernel-space" class="headerlink" title="Traps from kernel space"></a>Traps from kernel space</h4><p><em>根据操作模式的不同，stvec 指向的汇编代码不同</em>。当从用户模式进入内核模式时，会使 stvec 指向 <em>kernelvec</em>。</p>
<blockquote>
<p>见 usertrap</p>
</blockquote>
<h5 id="kernelvec：进入"><a href="#kernelvec：进入" class="headerlink" title="kernelvec：进入"></a>kernelvec：进入</h5><p>kernelvec <em>保存所有的寄存器到中断的内核线程的堆栈上</em>，以便中断的代码可以在稍后恢复而不受干扰。</p>
<blockquote>
<p>这很合理，因为寄存器的值属于该线程。如果 trap 导致了线程切换，这一点尤为重要——在这种情况下，trap 实际上会在新线程的堆栈上返回，从而将被中断的线程的保存寄存器安全地留在其堆栈上。</p>
</blockquote>
<p>然后跳转到 <em>kerneltrap</em></p>
<h5 id="kerneltrap：进入"><a href="#kerneltrap：进入" class="headerlink" title="kerneltrap：进入"></a>kerneltrap：进入</h5><p>kerneltrap <em>只需要处理两种类型的异常</em>：设备中断则调用 devintr，异常则 <em>panic</em> 并停止执行</p>
<h6 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h6><p>如果设备中断由定时器中断引起，并且有至少一个非调度器线程的内核线程，则通过 <em>yield</em> 让出CPU给其他线程。</p>
<p>最终，其中一个线程会调用 yield，让我们的线程和其 kerneltrap 再次恢复。</p>
<h5 id="kerneltrap：返回"><a href="#kerneltrap：返回" class="headerlink" title="kerneltrap：返回"></a>kerneltrap：返回</h5><p>由于 yield 可能扰乱 sepc 和 sstaus 中的值，kerneltrap 会在最开始保存它们，<em>并在处理 trap 后恢复</em></p>
<p>最后返回到 kernelvec</p>
<h5 id="kernelvec：返回"><a href="#kernelvec：返回" class="headerlink" title="kernelvec：返回"></a>kernelvec：返回</h5><p>返回到 kernelvec 后，kernelvec 从堆栈中弹出保存的寄存器，通过 sret 将 sepc 复制到 pc，并恢复中断的代码</p>
<h5 id="usertrap：防止设备中断"><a href="#usertrap：防止设备中断" class="headerlink" title="usertrap：防止设备中断"></a>usertrap：防止设备中断</h5><p>当从用户模式进入内核模式时，最初的 stvec 指向 uservec，<em>在这个窗口期必须禁用设备中断，在设置 stvec 之前不会重新启用它们。</em></p>
<h4 id="Real-World"><a href="#Real-World" class="headerlink" title="Real World"></a>Real World</h4><p>适当的带权限映射可以避免使用 trampoline 页，从而避免页表切换、直接使用用户地址空间</p>
<p>但这也可能使得不慎使用用户指针而导致安全问题、增加了用户和内核虚拟地址重叠所带来的的复杂性。</p>
<h3 id="Trap-机制"><a href="#Trap-机制" class="headerlink" title="Trap 机制"></a>Trap 机制</h3><p>每当系统调用、异常、设备中断时，会发生用户和内核空间的切换，称为 trap。</p>
<blockquote>
<p>trap 发生得很频繁，其设计中有很多对安全隔离和性能来说非常重要的细节</p>
</blockquote>
<p>那么问题来了，如何从只有 user 权限的空间切换到内核？<em>主要依靠硬件</em></p>
<h4 id="Supervisor-寄存器"><a href="#Supervisor-寄存器" class="headerlink" title="Supervisor 寄存器"></a>Supervisor 寄存器</h4><p>32个用户寄存器中，很多寄存器都有特殊的作用，如：SP、RA。此外还有一些权限寄存器，用户模式下不能访问：<em>pc、操作模式标志位、satp、stvec、sepc、sscratch</em>，这些寄存器都表明了发生 trap 时计算机的状态</p>
<blockquote>
<p>具体介绍见课前</p>
</blockquote>
<h5 id="特权模式不特权"><a href="#特权模式不特权" class="headerlink" title="特权模式不特权"></a>特权模式不特权</h5><p>改变操作模式后可以干什么？读写控制寄存器、以及使用用户模式下被禁用的PTE</p>
<p>——除此之外没有更多的事情可以干，我们仍受限于PT，所以不能读写任意物理地址：不在PT中的不能读写，设置PTE_U的也不能读写</p>
<h4 id="用户空间-trap"><a href="#用户空间-trap" class="headerlink" title="用户空间 trap"></a>用户空间 trap</h4><p>当在用户空间发生trap时，所有的计算机状态都被设置为用户模式相关，我们需要更改一些状态，以切换到内核模式。有一些操作是我们必须要做的：<em>保存32个用户寄存器、保存pc、切换操作模式、切换satp、设置堆栈、跳转到内核C代码</em></p>
<h4 id="隔离性与透明"><a href="#隔离性与透明" class="headerlink" title="隔离性与透明"></a>隔离性与透明</h4><blockquote>
<p>操作系统的一些high-level的目标能帮我们过滤一些实现选项。其中一个目标是安全和隔离，我们不想让用户代码介入到这里的user&#x2F;kernel切换，否则有可能会破坏安全性。所以这意味着，trap中涉及到的硬件和内核机制不能依赖任何来自用户空间东西。比如说我们不能依赖32个用户寄存器，它们可能保存的是恶意的数据，所以，XV6的trap机制不会查看这些寄存器，而只是将它们保存起来。</p>
</blockquote>
<p>在操作系统的trap机制中，我们仍然想保留<em>隔离性</em>并防御来自用户代码的可能的恶意攻击。同样也很重要的是，另一方面，我们想要让trap机制对用户代码是<em>透明的</em>，也就是说我们想要执行trap，然后在内核中执行代码，同时用户代码并不用察觉到任何有意思的事情。这样也更容易写用户代码。</p>
<h3 id="Trap代码执行流程"><a href="#Trap代码执行流程" class="headerlink" title="Trap代码执行流程"></a>Trap代码执行流程</h3><blockquote>
<p>我首先会简单介绍一下trap代码的执行流程，但是这节课大部分时间都会通过gdb来跟踪代码是如何通过trap进入到内核空间，这里会涉及到很多的细节。为了帮助你提前了解接下来的内容，我们会跟踪如何在Shell中调用write系统调用。</p>
</blockquote>
<p>在 write 调用的过程中，首先把参数放到指定寄存器，通过 <em>ecall</em> 触发进入内核：</p>
<p>首先执行的是一个汇编函数：<em>uservec</em>，然后我们跳转到一个C函数 <em>usertrap</em>，它根据 trap 类型调用了 <em>syscall</em>，syscall 调用实现了相关功能的系统调用函数 <em>sys_write</em>，sys_write 执行后就会返回到 <em>syscall</em>。</p>
<p>返回时我们需要恢复用户空间的数据，syscall 会调用 <em>usertrapret</em>，除此之外还有一些工作只能在汇编中完成，于是 usertrapret 会调用 <em>userret</em>，userret 会调用机器指令返回到用户空间，恢复 ecall 之后的用户程序执行</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/image%2020.avif" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/image%2020.avif" class title="image 20.avif"></a>


<blockquote>
<p>学生提问：这个问题或许并不完全相关，read和write系统调用，相比内存的读写，他们的代价都高的多，因为它们需要切换模式，并来回捣腾。有没有可能当你执行打开一个文件的系统调用时， 直接得到一个page table映射，而不是返回一个文件描述符？这样只需要向对应于设备的特定的地址写数据，程序就能通过page table访问特定的设备。你可以设置好限制，就像文件描述符只允许修改特定文件一样，这样就不用像系统调用一样在用户空间和内核空间来回捣腾了。</p>
<p>Robert教授：这是个很好的想法。实际上很多操作系统都提供这种叫做内存映射文件（Memory-mapped file access）的机制，在这个机制里面通过page table，可以将用户空间的虚拟地址空间，对应到文件内容，这样你就可以通过内存地址直接读写文件。实际上，你们将在mmap 实验中完成这个机制。对于许多程序来说，这个机制的确会比直接调用read&#x2F;write系统调用要快的多。</p>
</blockquote>
<h3 id="ECALL-之前的状态"><a href="#ECALL-之前的状态" class="headerlink" title="ECALL 之前的状态"></a>ECALL 之前的状态</h3><blockquote>
<p>以 write 为例（user&#x2F;usys.S）</p>
</blockquote>
<h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><p>放了个系统调用号到 a7，然后就ecall，ecall 返回后就 ret 到之后的指令</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813103756.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813103756.png" class title="Pasted image 20240813103756.png"></a>

<p>找到 ecall 地址并设置断点：</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813104559.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813104559.png" class title="Pasted image 20240813104559.png"></a>

<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813104706.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813104706.png" class title="Pasted image 20240813104706.png"></a>

<p>查看此时的寄存器：</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813104834.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813104834.png" class title="Pasted image 20240813104834.png"></a>

<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813104940.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813104940.png" class title="Pasted image 20240813104940.png"></a>

<p>a0 为fd，a1为要写入的字符串，a2为写入的字符数。另外，我们此时确实处于用户空间，上述图片显示我们此时离0很近，而内核会使用大得多的内存地址放指令。</p>
<h4 id="此时的页表"><a href="#此时的页表" class="headerlink" title="此时的页表"></a>此时的页表</h4><p>此时的 satp（页表物理地址） 为：</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813105827.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813105827.png" class title="Pasted image 20240813105827.png"></a>

<p>从 QEMU 界面查看当前页表（ctrl a+c）：</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813110003.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813110003.png" class title="Pasted image 20240813110003.png"></a>

<p>这是 shell 的页表，第五行为栈，第四行为 guard 页（<em>没有设置u</em>)，第六行为我们之前设置的共享空间。再往下就是 trapframe 和 trampoline，用户不能使用它们。</p>
<blockquote>
<p>对于这里page table，有一件事情需要注意：它并没有包含任何内核部分的地址映射，这里既没有对于kernel data的映射，也没有对于kernel指令的映射。除了最后两条PTE，这个page table几乎是完全为用户代码执行而创建，所以它对于在内核执行代码并没有直接特殊的作用。</p>
</blockquote>
<p>a表示access，是否使用过；d表示 dirty，是否写过。这些标志为由硬件维护以方便OS使用</p>
<blockquote>
<p>对于比XV6更复杂的操作系统，当物理内存吃紧的时候，可能会通过将一些内存写入到磁盘来，同时将相应的PTE设置成无效，来释放物理内存page。你可以想到，这里有很多策略可以让操作系统来挑选哪些page可以释放。我们可以查看a标志位来判断这条PTE是否被使用过，如果它没有被使用或者最近没有被使用，那么这条PTE对应的page适合用来保存到磁盘中。类似的，d标志位告诉内核，这个page最近被修改过。</p>
<p>不过XV6没有这样的策略。</p>
</blockquote>
<h3 id="ECALL指令之后的状态"><a href="#ECALL指令之后的状态" class="headerlink" title="ECALL指令之后的状态"></a>ECALL指令之后的状态</h3><h4 id="ecall"><a href="#ecall" class="headerlink" title="ecall"></a>ecall</h4><p>执行 ecall，根据上面的页表，可以知道我们现在在 <em>trampoline</em> 页：</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813111211.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813111211.png" class title="Pasted image 20240813111211.png"></a>

<p>可以看到ecall<em>使用了 stvec 中的值</em>，帮助我们跳转到 trampoline 页：</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813112837.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813112837.png" class title="Pasted image 20240813112837.png"></a>

<ul>
<li>在切换到用户空间前，内核会设置好stvec的值</li>
</ul>
<p>我们现在已经处在内核模式了，最直观的，我们可以使用trampoline页而程序没有崩溃</p>
<p>ecall 还<em>把 pc 保存到 sepc</em>：</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813113427.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813113427.png" class title="Pasted image 20240813113427.png"></a>

<p>也就是说，<em>ecall 总共干了三件事：切换到内核模式、保存pc到sepc、跳转到 stvec 指向的指令（通过保存它的地址到pc实现）</em></p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>如果在 qemu 中查看当前页表，会发现页表并没有发生变化，也就是说，<em>ecall并不会切换page table</em>，这意味着要跳转到 trap 处理的下一步的代码，必须<em>在每一个进程中都映射 trampoline 页</em></p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813111312.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813111312.png" class title="Pasted image 20240813111312.png"></a>


<h4 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h4><blockquote>
<p>所以现在，ecall帮我们做了一点点工作，但是实际上我们离执行内核中的C代码还差的很远</p>
</blockquote>
<p>我们下来需要：<em>保存32个用户寄存器、切换到内核页表、找一个内核栈、跳转到合适的C代码</em></p>
<h5 id="为什么ecall不让硬件替我们完成这些事？"><a href="#为什么ecall不让硬件替我们完成这些事？" class="headerlink" title="为什么ecall不让硬件替我们完成这些事？"></a>为什么ecall不让硬件替我们完成这些事？</h5><blockquote>
<p>ecall 是一条CPU指令</p>
</blockquote>
<blockquote>
<p>在软件中完成这些工作并不是特别简单</p>
</blockquote>
<p>实际上，有的机器在执行系统调用时，会在硬件中完成所有这些工作。但是RISC-V并不会，RISC-V秉持了这样一个观点：ecall只完成尽量少必须要完成的工作，其他的工作都交给软件完成。这里的原因是，RISC-V设计者想要为软件和操作系统的程序员提供最大的<em>灵活性</em>，这样他们就能按照他们想要的方式开发操作系统。所以你可以这样想，尽管XV6并没有使用这里提供的灵活性，但是一些其他的操作系统用到了。</p>
<ul>
<li><p>举个例子，因为这里的ecall是如此的简单，或许某些操作系统可以在不切换page table的前提下，执行部分系统调用。切换page table的代价比较高，如果ecall打包完成了这部分工作，那就不能对一些系统调用进行改进，使其不用在不必要的场景切换page table。</p>
</li>
<li><p>某些操作系统同时将user和kernel的虚拟地址映射到一个page table中，这样在user和kernel之间切换时根本就不用切换page table。对于这样的操作系统来说，如果ecall切换了page table那将会是一种浪费，并且也减慢了程序的运行。</p>
</li>
<li><p>或许在一些系统调用过程中，一些寄存器不用保存，而哪些寄存器需要保存，哪些不需要，取决于于软件，编程语言，和编译器。通过不保存所有的32个寄存器或许可以节省大量的程序运行时间，所以你不会想要ecall迫使你保存所有的寄存器。</p>
</li>
<li><p>最后，对于某些简单的系统调用或许根本就不需要任何stack，所以对于一些非常关注性能的操作系统，ecall不会自动为你完成stack切换是极好的。</p>
</li>
</ul>
<h3 id="uservec函数"><a href="#uservec函数" class="headerlink" title="uservec函数"></a>uservec函数</h3><h4 id="保存用户寄存器"><a href="#保存用户寄存器" class="headerlink" title="保存用户寄存器"></a>保存用户寄存器</h4><p>此时的寄存器全是用户数据，在保存它们之前，我们不能使用任何寄存器，也就基本上不能干任何事。页表也没有切换，我们也不能把这些寄存器直接保存到内存（其他机制的机器或许可以）</p>
<blockquote>
<p>一种可能的机制是，ecall 直接将SATP寄存器指向kernel page table，然后就可以存储用户寄存器</p>
<p>Q：为什么不保存到用户栈中？<br>A：<em>我们不确定用户程序是否有栈</em>，有些编程语言没有栈，它的sp指向一个无效值，可能使用堆保存数据。也即，<em>OS不能假设用户地址空间的格式</em>，除非自己给他安排（trampoline和trapframe）。不能假设用户内存的哪部分可以访问，哪部分有效，哪部分存在。<em>所以内核需要自己管理这些寄存器的保存</em>，这就是为什么内核将这些内容保存在属于内核内存的trapframe中，而不是用户内存。</p>
</blockquote>
<p>对于保存用户寄存器，xv6 在创建每个进程时，为其页表映射了一个 <em>TRAPFRAME</em> 页，专门用于保存这些数据：</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813115342.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813115342.png" class title="Pasted image 20240813115342.png"></a>

<p>此外还有一些切换到用户空间前设置好的数据：kernel_*，epc 保存 sepc 中的数据</p>
<p>我们之前提到过 <em>SSCRATCH</em> 寄存器，<em>在进入到用户进程前，内核会保存本进程的 trapframe 地址到这个寄存器</em>，也就是 TRAPFRAME。</p>
<p>RISC-V 还提供了一个指令允许交换任意两个寄存器的值：<em>csrw</em>，我们做的第一件事就是交换 a0 和 sscratch。然后我们保存除a0外的所有寄存器：</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813123238.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813123238.png" class title="Pasted image 20240813123238.png"></a>

<blockquote>
<p>为什么不直接用 ssratch 的值做偏移保存？因为这是控制和状态寄存器 csr，必须用特殊的指令访问</p>
</blockquote>
<p>接着我们从 ssratch 中取回a0并保存：</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813123553.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813123553.png" class title="Pasted image 20240813123553.png"></a>

<p>于是我们保存了所有的用户寄存器，现在我们可以使用所有的用户寄存器。接下来我们需要为内核的运行准备环境</p>
<h4 id="准备内核环境：栈和页表"><a href="#准备内核环境：栈和页表" class="headerlink" title="准备内核环境：栈和页表"></a>准备内核环境：栈和页表</h4><ol>
<li>加载 <em>sp</em>，以准备 <em>内核栈</em>：</li>
</ol>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813124026.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813124026.png" class title="Pasted image 20240813124026.png"></a>

<blockquote>
<p>a0偏移8刚好是 kernel_sp</p>
</blockquote>
<p>这便是本内核进程的内核栈位置</p>
<blockquote>
<p>每个内核栈下面都有guard page</p>
</blockquote>
<ol start="2">
<li>加载 <em>tp</em>，thread pointer。这可以帮助我们确认运行在多核处理器的哪个核上，核用 <em>hartid</em> 标识</li>
</ol>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813132033.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813132033.png" class title="Pasted image 20240813132033.png"></a>

<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813132052.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813132052.png" class title="Pasted image 20240813132052.png"></a>

<ol start="3">
<li>加载 <em>usertrap</em> 的指针、<em>kernel page table</em> 的地址 到临时寄存器：t0、t1，然后交换 t1 和 satp</li>
</ol>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813132602.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813132602.png" class title="Pasted image 20240813132602.png"></a>
<blockquote>
<p>严格来说这不是内核页表的地址，它需要经过移位</p>
</blockquote>
<p>此时的页表和之前完全不同：</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813132649.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813132649.png" class title="Pasted image 20240813132649.png"></a>

<p>于是<em>我们成功设置了内核栈指针、切换了内核页表</em>，可以跳转到C代码了：</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813132904.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813132904.png" class title="Pasted image 20240813132904.png"></a>

<blockquote>
<p>t0中的vm不变，而我们切换了页表，为什么 t0 中 usertrap 的地址仍然有效，而不是让我们跳转到一些无关的页面？</p>
<p>因为 trampoline 在用户和内核空间中映射到了相同的虚拟地址。其他页映射完全不同，<em>这就是 trampoline page 的特殊之处</em></p>
<p>emm 就算映射不同，t0是从 trapframe 中来的，可以在返回用户空间前就给 trapframe 赋值内核中 usertrap 的vm吧？所以映射不同似乎也完全ok？</p>
</blockquote>
<h3 id="usertrap函数"><a href="#usertrap函数" class="headerlink" title="usertrap函数"></a>usertrap函数</h3><p><em>这是所有来自用户空间的 trap entry，也是 trap exit</em>。系统调用、异常、设备中断都会途径这段代码。由于这些原因，usertrap 有必要<em>保存并恢复硬件状态、以及根据 trap 类型跳转到相应的函数</em></p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813163742.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813163742.png" class title="Pasted image 20240813163742.png"></a>

<p>它所做的第一件事就是 <em>更改 stvec，使其指向 kernelvec</em>。</p>
<blockquote>
<p>我们目前处于内核空间，如果再次发生 trap 需要进行与 trap from user space 非常不同的处理。因为在内核空间，我们可以用堆栈、页表，一些对于用户来说有必要的操作在内核面前完全没必要</p>
</blockquote>
<p>出于各种原因，<em>我们还需要知道当前运行的是什么进程</em>。</p>
<blockquote>
<p>myproc 调用链上的一系列函数会根据 tp 中的 hartid 找到当前的CPU信息结构体，进而获得运行的进程信息结构体指针</p>
</blockquote>
<p>接着我们把保存在 sepc 中的 <em>pc 值存储到 trapframe 中的 epc 中</em></p>
<blockquote>
<p>一旦发生 trap，<em>pc 直接就被硬件复制到 sepc，并且关闭设备中断</em>，紧接着的 uservec 会覆盖掉 pc。执行过程中，如果再次发生进程调度，切换到另一个进程，然后发生 trap，sepc 也会被覆盖掉，所以需要将 sepc 保存到与该进程相关的 epc 中</p>
</blockquote>
<p>接着 <em>根据 scause 找出发生 trap 的原因</em>，8 表示发生系统调用。如果是系统调用，<em>先检查当前进程有没有被杀掉</em>，如果没有杀掉则 <em>进入 syscall</em>。</p>
<blockquote>
<p>值得注意的是，进入syscall前需要给 trapframe 中的 <em>epc 加4</em>，以使得返回时执行下一条语句，<em>并开启中断</em>，防止系统调用耽搁太多时间</p>
</blockquote>
<p>然后就是我们熟悉的 syscall：根据a7调用sys_*，返回时将返回值放到a0（trapframe）。相关sys函数执行时也是通过argxxx，使用trapframe获取参数。</p>
<p>接着返回到 usertrap，<em>先检查要返回的进程有没有被杀死</em>，若没有则继续执行 <em>usertrapret</em></p>
<h3 id="usertrapret函数"><a href="#usertrapret函数" class="headerlink" title="usertrapret函数"></a>usertrapret函数</h3><p><em>它首先关闭了设备中断</em>，为了防止更新 stvec 后再次发生 trap，而走向 uservec——现在处于内核空间</p>
<p>接着 <em>更新 stvec 指向 trampoline 中的 uservec</em></p>
<p>然后 <em>填入 trapframe 中的 kernel_satp、kernel_sp、kernel_trap、kernel_hartid 字段</em>，其中的 kernel_trap 其实是kernel代码中的 usertrap 函数，kernel_hartid 用于下次进入该线程时设置 tp</p>
<blockquote>
<p>每次返回用户进程都会设置 kernel_hartid，而被其他CPU调度也需要从内核返回用户空间，所以下次进入trap时，kernel_hartid一定是当前CPU的id</p>
</blockquote>
<blockquote>
<p><em>任何经过编译的代码都不能修改用户寄存器</em>——编译器要组织使用这些寄存器，所以保存用户寄存器的工作被放在汇编代码 uservec 中。实际上也可以在 uservec 中保存 sepc 到 epc，这都是ok的。对于用户寄存器，必须再进入C代码前保存好，而控制寄存器如 sepc 早点晚点都无所谓</p>
</blockquote>
<p>接下来设置控制寄存器：</p>
<ol>
<li>设置 <em>SPP</em> 为0，表示进入 trap 前处于用户模式，<em>sret</em> 会因此带着我们返回到用户模式。 设置 <em>SIE</em> 为 SPIE，从而打开中断，将这些操作的结果 <em>写回 SSTATUS</em></li>
<li>设置 <em>sepc</em> 为 trapframe 中保存的 epc。trampoline 中的 sret 会设置 pc 为 sepc </li>
<li>准备好 <em>用户页表</em> 的值，和 <em>TRAPFRAME</em> 一起传递给 trampoline 中的 <em>userret</em></li>
</ol>
<blockquote>
<p>在 trampoline 中切换页表，因为此时还需要用到内核空间的一些数据</p>
</blockquote>
<h3 id="userret函数"><a href="#userret函数" class="headerlink" title="userret函数"></a>userret函数</h3><p>我们有两个参数分别放在 a0 和 a1中：TRAPFRAME 以及 satp值，首先 <em>切换页表</em>，并清空页表缓存：</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813180305.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813180305.png" class title="Pasted image 20240813180305.png"></a>

<blockquote>
<p>trampoline 在用户和内核空间中被映射到了相同的vm，所以我们的程序在切换页表后还能正常运行</p>
</blockquote>
<p>然后设置 <em>SSCRATCH</em> 为 系统调用的返回值 a0：</p>
<a href="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813180558.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/13/6.s081%20lec6%20System%20Call%20Entry%20and%20Exit/Pasted%20image%2020240813180558.png" class title="Pasted image 20240813180558.png"></a>

<blockquote>
<p>a0此时放的是 trapframe 指针，trapframe 中的 a0 会覆盖原来 trapframe保存的a0</p>
</blockquote>
<p>接着<em>恢复除a0外所有的寄存器</em>，最后<em>交换SSCRATCH和a0</em>，从而得到返回值，以及使得SSCRATCH指向trapframe</p>
<p>最后是 sret：设置 <em>pc</em> 为sepc的值，切换<em>操作模式</em>为SPP标识的模式，打开<em>中断</em></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>最后总结一下，系统调用被刻意设计的看起来像是函数调用，但是背后的user&#x2F;kernel转换比函数调用要复杂的多。之所以这么复杂，很大一部分原因是要保持user&#x2F;kernel之间的<em>隔离性</em>，内核不能信任来自用户空间的任何内容。</p>
<p>另一方面，XV6实现trap的方式比较特殊，XV6并不关心性能。但是通常来说，操作系统的设计人员和CPU设计人员非常关心如何提升<em>trap的效率和速度</em>。必然还有跟我们这里不一样的方式来实现trap，当你在实现的时候，可以从以下几个问题出发：</p>
<ul>
<li><p>硬件和软件需要协同工作，你可能需要重新设计XV6，重新设计RISC-V来使得这里的处理流程更加简单，更加快速。</p>
</li>
<li><p>另一个需要时刻记住的问题是，恶意软件是否能滥用这里的机制来打破隔离性。</p>
</li>
</ul>
<p>好的，这就是这节课的全部内容。</p>
</blockquote>
</div><script src="https://jsd.cdn.zzko.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if("undefined"!=typeof lightGallery) {
        var options1 = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1);
        }</script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-08-13</span>
            
                <span>该篇文章被 Toki</span>
            
            
             
                <span>归为分类:
                    
                    
                        <a href='/categories/6-s081/'>
                            6.s081
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 2024 

            
                

            
                
                    / <a href="/contact/"> 联系 </a>
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
            
    </body>
</html>