<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="lec9 Interrupts and Device Drivers" />
    <meta name="hexo-theme-A4" content="v1.9.2" />
    <link rel="alternate icon" type="image/webp" href="/img/logo.jpg">
    <title>Toki</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.2.0"></head>
    
    
        <style>
            .index-main{
                max-width:  880px;
            }
        </style>

    
    



    

    
    

    
    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #e4e4e4 ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/logo.jpg" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Toki</a> 
            <span class="description">Why so serious?</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
            
                <li><a href="/contact/">联系</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        
            
                <div class="post-main-title">
                    lec9 Interrupts and Device Drivers
                </div>
            
        
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Interrupts-and-Device-Drivers"><span class="post-toc-text">Interrupts and Device Drivers</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%AF%BE%E5%89%8D%E5%87%86%E5%A4%87"><span class="post-toc-text">课前准备</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Code-Console-input"><span class="post-toc-text">Code: Console input</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#UART%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="post-toc-text">UART：控制寄存器</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#consoleinit"><span class="post-toc-text">consoleinit</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#shell-%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5"><span class="post-toc-text">shell 读取输入</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#devintr"><span class="post-toc-text">devintr</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#uartintr-%E4%B8%8E-consoleintr"><span class="post-toc-text">uartintr 与 consoleintr</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Code-Console-output"><span class="post-toc-text">Code: Console output</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E-uartputc"><span class="post-toc-text">输出缓冲区与 uartputc</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AE%8C%E6%88%90%E4%B8%AD%E6%96%AD%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="post-toc-text">完成中断与输出</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%AE%BE%E5%A4%87%E6%B4%BB%E5%8A%A8%E4%B8%8E%E8%BF%9B%E7%A8%8B%E6%B4%BB%E5%8A%A8%E7%9A%84%E8%A7%A3%E8%80%A6"><span class="post-toc-text">设备活动与进程活动的解耦</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Concurrency-in-drivers"><span class="post-toc-text">Concurrency in drivers</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Timer-interrupts"><span class="post-toc-text">Timer interrupts</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Timer-interrupts%EF%BC%9A%E6%9C%BA%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">Timer interrupts：机器模式</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#main%E4%B9%8B%E5%89%8D%EF%BC%9Astart"><span class="post-toc-text">main之前：start</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8F%91%E7%94%9F%E6%97%B6%E6%9C%BA"><span class="post-toc-text">发生时机</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#timervec"><span class="post-toc-text">timervec</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Real-World"><span class="post-toc-text">Real World</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="post-toc-text">定时器带来的复杂性</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%B9%81%E9%87%8D%E6%80%A7"><span class="post-toc-text">驱动程序的繁重性</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%8C%96I-O-%E4%B8%8E-DMA"><span class="post-toc-text">程序化I&#x2F;O 与 DMA</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%89%B9%E9%87%8F%E4%B8%AD%E6%96%AD"><span class="post-toc-text">批量中断</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#UART-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%8C%E9%87%8D%E5%A4%8D%E5%88%B6"><span class="post-toc-text">UART 驱动程序的双重复制</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%9C%9F%E5%AE%9E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="post-toc-text">真实操作系统内存使用情况</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Interrupt-%E7%A1%AC%E4%BB%B6%E9%83%A8%E5%88%86"><span class="post-toc-text">Interrupt 硬件部分</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E7%89%B9%E7%82%B9"><span class="post-toc-text">中断的特点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BB%8E%E5%93%AA%E9%87%8C%E4%BA%A7%E7%94%9F%EF%BC%9F"><span class="post-toc-text">中断从哪里产生？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#PLIC"><span class="post-toc-text">PLIC</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#PLIC-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="post-toc-text">PLIC 中断处理流程</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A6%82%E8%BF%B0"><span class="post-toc-text">设备驱动概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#bottom"><span class="post-toc-text">bottom</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#top"><span class="post-toc-text">top</span></a></li></ol></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="https://jsd.cdn.zzko.cn/npm/hexo-theme-a4@latest/source/css/lightgallery.min.css"><div class=".article-gallery"><h2 id="Interrupts-and-Device-Drivers"><a href="#Interrupts-and-Device-Drivers" class="headerlink" title="Interrupts and Device Drivers"></a>Interrupts and Device Drivers</h2><h3 id="课前准备"><a href="#课前准备" class="headerlink" title="课前准备"></a>课前准备</h3><p><code>驱动程序</code>用于管理特定设备，其行为包含：配置、指示操作、处理中断、与进程交互。它与设备是<code>并发</code>执行的，代码较为复杂；同时还必须理解硬件的设备接口</p>
<p>需要OS关注的硬件设备通常可以生成中断，内核识别 trap 并调用处理程序 <code>devintr</code> </p>
<blockquote>
<p>kernel&#x2F;trap.c：devintr</p>
</blockquote>
<p><code>驱动程序通常分为两部分</code>，一部分接收系统调用、对设备进行I&#x2F;O、让进程进行等待，另一部分确定哪个设备操作已经完成、并唤醒等待的进程、然后告诉硬件开始处理等待中的下一个操作</p>
<h4 id="Code-Console-input"><a href="#Code-Console-input" class="headerlink" title="Code: Console input"></a>Code: Console input</h4><p>console 控制程序连接到 <code>UART</code> 串行端口硬件接受人类输入的字符，一次接受一行，用户程序通过read读取这些字符</p>
<blockquote>
<p>The UART hardware that the driver talks to is a 16550 chip  emulated by QEMU. On a real computer, a 16550 would manage an RS232 serial link connecting to a terminal or other computer. When running QEMU, it’s connected to your keyboard and display.</p>
</blockquote>
<p>UART的内存映射地址从 <code>0x10000000</code> 开始，或者称为 UART0（kernel&#x2F;memlayout.h）。与它的交互<code>不通过内存</code>。</p>
<h5 id="UART：控制寄存器"><a href="#UART：控制寄存器" class="headerlink" title="UART：控制寄存器"></a>UART：控制寄存器</h5><p>UART 有少量的<code>控制寄存器</code>，每个寄存器长一个字节，其相对于UART0的偏移量在（kernel&#x2F;uart.c）中定义</p>
<ul>
<li><code>LSR</code>：line status register，是否有输入字符等待被软件读取</li>
<li><code>RHR</code>：receive holding register，用于读取字符。读取后UART会从其内部等待字符FIFO中删除它，读取所有等待字符后设置LSR为空</li>
<li><code>THR</code>：transmit holding register，软件写入字节</li>
</ul>
<p>UART <code>发送硬件与接收硬件基本独立</code></p>
<h5 id="consoleinit"><a href="#consoleinit" class="headerlink" title="consoleinit"></a>consoleinit</h5><p>Xv6的main函数调用consoleinit（kernel&#x2F;console.c）来初始化UART硬件。这段代码配置UART，以便在UART接收到每个输入字节时生成<code>接收中断</code>，并且每次UART完成发送一个输出字节时生成发送<code>完成中断</code></p>
<h5 id="shell-读取输入"><a href="#shell-读取输入" class="headerlink" title="shell 读取输入"></a>shell 读取输入</h5><p>xv6 shell通过init.c打开的 <code>文件描述符</code> 从控制台读取输入，对 <code>read</code> 的系统调用最终会通过内核传递到 <code>consoleread</code></p>
<p>consoleread 等待缓存在 <code>cons.buf</code> 中的输入到达（通过中断）后，将输入复制到用户空间，并在整个行到达后返回给用户进程。在输入一行完成前，任何读取的进程会在 <code>sleep</code> 中等待。</p>
<h5 id="devintr"><a href="#devintr" class="headerlink" title="devintr"></a>devintr</h5><p>当用户输入一个字符时，UART硬件会请求RISC-V触发中断，从而激活xv6的trap处理程序。</p>
<p>trap处理程序调用 <code>devintr</code>，该函数查看RISC-V的 <code>scause</code> 寄存器，发现中断来自外部设备。然后，它请求名为 <code>PLIC</code> 的硬件单元告知是哪台设备引发了中断。如果是UART，devintr会调用 <code>uartintr</code>。</p>
<h5 id="uartintr-与-consoleintr"><a href="#uartintr-与-consoleintr" class="headerlink" title="uartintr 与 consoleintr"></a>uartintr 与 consoleintr</h5><p>从UART硬件读取任何等待的输入字符并将其交给 <code>consoleintr</code>，<code>它不会等待字符</code>，因为未来的输入将触发新的中断。</p>
<p>consoleintr 将输入字符累积到 <code>cons.buf</code> 中，直到接收到完整的一行。它会特别处理退格键和其他一些字符。当收到换行符时，consoleintr 会唤醒正在等待的 <code>consoleread</code>，由它将其复制到用户空间，并返回到用户空间（通过系统调用机制）。</p>
<h4 id="Code-Console-output"><a href="#Code-Console-output" class="headerlink" title="Code: Console output"></a>Code: Console output</h4><p>连接到控制台的 <code>文件描述符</code> 上的 <code>write</code> 系统调用最终会到达 <code>uartputc</code> 函数。</p>
<h5 id="输出缓冲区与-uartputc"><a href="#输出缓冲区与-uartputc" class="headerlink" title="输出缓冲区与 uartputc"></a>输出缓冲区与 uartputc</h5><p>驱动程序维护了一个 <code>输出缓冲区</code>  uart_tx_buf，因此写入的进程 <code>不必等待</code> UART完成发送操作，由 <code>uartputc</code> 将每个字符附加到缓冲区，并调用 <code>uartstart</code> 启动设备传输。uartputc唯一等待的情况就是输出缓冲区满了</p>
<h5 id="完成中断与输出"><a href="#完成中断与输出" class="headerlink" title="完成中断与输出"></a>完成中断与输出</h5><p>每次UART完成发送一个字节时，它会生成一个中断。<code>uartintr</code> 会调用 <code>uartstart</code>，该函数会检查设备是否确实完成了发送，并将下一个缓冲的输出字符交给设备。</p>
<p>因此，如果一个进程向控制台写入多个字节，通常<code>第一个字节会由uartputc调用uartstart发送</code>，剩下的缓冲字节则由uartintr在接收到发送完成的中断后，通过调用uartstart发送。</p>
<h5 id="设备活动与进程活动的解耦"><a href="#设备活动与进程活动的解耦" class="headerlink" title="设备活动与进程活动的解耦"></a>设备活动与进程活动的解耦</h5><p>一般模式是通过 <code>缓冲和中断</code> 实现设备活动与进程活动的解耦：</p>
<ul>
<li><p>即使没有进程等待读取，控制台驱动程序也可以处理输入；后续的读取操作将获取到这些输入。</p>
</li>
<li><p>同样，进程可以发送输出而不必等待设备完成。这种解耦可以通过允许进程与设备I&#x2F;O并发执行来提高性能</p>
</li>
</ul>
<p>这在设备速度较慢（如UART）或需要立即响应（如回显输入字符）时尤为重要。这种思想有时被称为<code>I/O并发</code>。</p>
<h4 id="Concurrency-in-drivers"><a href="#Concurrency-in-drivers" class="headerlink" title="Concurrency in drivers"></a>Concurrency in drivers</h4><p>console 驱动程序的数据结构可能会受<code>并发访问</code>的影响</p>
<p>这里存在<code>三个并发风险</code>：两个位于不同CPU上的进程可能会同时调用consoleread；硬件可能会请求某个CPU在执行consoleread时处理控制台（实际上是UART）的中断；硬件还可能在consoleread执行时在不同的CPU上发出控制台中断。</p>
<p>并发需要在驱动程序中小心处理的另一个方面是，一个进程可能在等待设备输入，而表示输入到达的中断信号可能在另一个进程（或者没有进程运行时）到达。因此，<code>中断处理程序无法考虑它们中断的进程或代码</code>。例如，中断处理程序不能安全地使用当前进程的页表调用copyout。</p>
<p><code>中断处理程序通常执行相对较少的工作</code>（例如，仅将输入数据复制到缓冲区），并唤醒上半部分的代码来完成其余的工作。</p>
<h4 id="Timer-interrupts"><a href="#Timer-interrupts" class="headerlink" title="Timer interrupts"></a>Timer interrupts</h4><p>Xv6 使用定时器中断来维护其<code>时钟</code>，并进行进程切换；usertrap 和 kerneltrap 中的 <code>yield</code> 调用触发了这种切换。定时器中断来自连接到每个 RISC-V CPU 的<code>时钟硬件</code>。Xv6 将这些时钟硬件设置为定期中断每个 CPU。</p>
<h5 id="Timer-interrupts：机器模式"><a href="#Timer-interrupts：机器模式" class="headerlink" title="Timer interrupts：机器模式"></a>Timer interrupts：机器模式</h5><p>RISC-V 要求定时器中断必须在机器模式下处理，执行时<code>没有分页</code>，并且使用了一组<code>独立的控制寄存器</code>。在这种情况下，使用普通的 trap 机制是不现实的，需要 <code>单独处理</code></p>
<h5 id="main之前：start"><a href="#main之前：start" class="headerlink" title="main之前：start"></a>main之前：start</h5><p>在 main 函数之前，start.c 中的<code>机器模式代码设置了接收定时器中断的环境</code>（kernel&#x2F;start.c:57）。</p>
<p>这项工作的一部分是编程 CLINT 硬件（核心本地中断器），使其在一定延迟后生成中断。</p>
<p>另一部分是设置一个类似于 trapframe 的临时区域，以帮助定时器中断处理程序保存寄存器和 CLINT 寄存器的地址。最后，start 将 mtvec 设置为 timervec 并启用定时器中断。</p>
<h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p>可以在用户或内核代码执行的任何时候发生，<code>无法被禁用</code>。</p>
<p>所以定时器中断处理程序必须以保证不会扰乱原程序，基本策略是触发软件中断，并允许内核禁用这些软件中断</p>
<h5 id="timervec"><a href="#timervec" class="headerlink" title="timervec"></a>timervec</h5><blockquote>
<p>kernel&#x2F;kernelvec.S，汇编代码</p>
</blockquote>
<p>这是定时器中断的中断向量，它<code>在 start 准备的临时区域中保存了一些寄存器</code>，告诉 CLINT 何时生成下一次定时器中断，请求 RISC-V 触发软件中断，恢复寄存器并返回。</p>
<h4 id="Real-World"><a href="#Real-World" class="headerlink" title="Real World"></a>Real World</h4><h5 id="定时器带来的复杂性"><a href="#定时器带来的复杂性" class="headerlink" title="定时器带来的复杂性"></a>定时器带来的复杂性</h5><p>内核代码可能会由于定时器中断被挂起，然后在不同的CPU上恢复，这给Xv6带来了一些复杂性。如果设备和定时器中断只在执行用户代码时发生，内核可以变得稍微简单一些。</p>
<h5 id="驱动程序的繁重性"><a href="#驱动程序的繁重性" class="headerlink" title="驱动程序的繁重性"></a>驱动程序的繁重性</h5><p>支持典型计算机上的所有设备并充分利用其功能是一项繁重的工作，因为有许多设备，这些设备具有许多功能，并且设备与驱动程序之间的协议可能复杂且文档不足。在许多操作系统中，驱动程序的代码量超过了核心内核的代码量。</p>
<h5 id="程序化I-O-与-DMA"><a href="#程序化I-O-与-DMA" class="headerlink" title="程序化I&#x2F;O 与 DMA"></a>程序化I&#x2F;O 与 DMA</h5><p>UART驱动程序通过读取UART控制寄存器逐字节检索数据；这种模式被称为<code>程序化I/O</code>，因为数据的传输是由软件驱动的。</p>
<p>程序化I&#x2F;O简单，但在高速数据传输时太慢。需要高速传输大量数据的设备通常使用直接内存访问（<code>DMA</code>）。DMA设备硬件直接将传入数据写入RAM，并从RAM读取传出数据。现代磁盘和网络设备使用DMA。DMA设备的驱动程序会在RAM中准备数据，然后通过单次写入控制寄存器，告诉设备处理准备好的数据。</p>
<h5 id="批量中断"><a href="#批量中断" class="headerlink" title="批量中断"></a>批量中断</h5><p>当设备在不可预测的时间需要关注且频率不太高时，中断是合理的。但是中断会带来较高的CPU开销。因此，像网络和磁盘控制器这样的高速设备使用一些技巧来减少中断的需求。</p>
<p>一种技巧是<code>为一批传入或传出的请求触发单次中断</code>。另一种技巧是驱动程序完全禁用中断，定期检查设备是否需要关注。这种技术称为<code>轮询</code>。如果设备操作非常快，轮询是合理的，但如果设备大部分时间处于空闲状态，它会浪费CPU时间。</p>
<blockquote>
<p>一些驱动程序根据当前设备的负载动态地在轮询和中断之间切换。</p>
</blockquote>
<h5 id="UART-驱动程序的双重复制"><a href="#UART-驱动程序的双重复制" class="headerlink" title="UART 驱动程序的双重复制"></a>UART 驱动程序的双重复制</h5><p>UART驱动程序首先将传入数据复制到内核中的缓冲区，然后再复制到用户空间。这在低数据速率下是合理的，但这种双重复制会显著降低处理生成或消耗数据非常快的设备的性能。一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常使用DMA技术</p>
<h3 id="真实操作系统内存使用情况"><a href="#真实操作系统内存使用情况" class="headerlink" title="真实操作系统内存使用情况"></a>真实操作系统内存使用情况</h3><p>执行 <code>top</code>：</p>
<a href="/2024/08/15/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240815160624.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/15/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240815160624.png" class title="Pasted image 20240815160624.png"></a>

<p>——<code>大部分内存都被用掉了</code>，其中很大一部分被用作 <code>buff/cache</code>，我们不想让物理内存闲置。这意味着如果需要新内存的话，必须撤回一些已有的内容</p>
<blockquote>
<p>RES：实际使用的内存数量，VIRT：虚拟内存地址空间的大小。可以看到RES远小于VIRT</p>
</blockquote>
<h3 id="Interrupt-硬件部分"><a href="#Interrupt-硬件部分" class="headerlink" title="Interrupt 硬件部分"></a>Interrupt 硬件部分</h3><h4 id="中断的特点"><a href="#中断的特点" class="headerlink" title="中断的特点"></a>中断的特点</h4><p>中断相比于其他的trap机制有一些不一样的地方：</p>
<ol>
<li><code>asynchronous</code>：Interrupt handler 不运行在任何特定进程的context中</li>
<li><code>concurrency</code>：外设和CPU是两个并行的设备</li>
<li><code>program device</code>：设备需要被编程才能使用。</li>
</ol>
<blockquote>
<p>设备的编程手册包含了它有什么样的寄存器，它能执行什么样的操作，在读写控制寄存器的时候，设备会如何响应。</p>
</blockquote>
<h4 id="中断从哪里产生？"><a href="#中断从哪里产生？" class="headerlink" title="中断从哪里产生？"></a>中断从哪里产生？</h4><p>主板上的各种线路将外设和CPU连接在一起，处理器通过Platform Level Interrupt Control，简称 <code>PLIC</code> 来处理设备中断。</p>
<h5 id="PLIC"><a href="#PLIC" class="headerlink" title="PLIC"></a>PLIC</h5><a href="/2024/08/15/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/image%2025.avif" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/15/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/image%2025.avif" class title="image 25.avif"></a>

<p>从左上角可以看出，我们有53个不同的来自于设备的中断。这些中断到达PLIC之后，PLIC会<code>路由</code>这些中断到某一个CPU的核。</p>
<p>如果所有的CPU核都正在处理中断，PLIC会保留中断直到有一个CPU核可以用来处理中断。所以PLIC需要保存一些内部数据来<code>跟踪中断的状态</code>。</p>
<h5 id="PLIC-中断处理流程"><a href="#PLIC-中断处理流程" class="headerlink" title="PLIC 中断处理流程"></a>PLIC 中断处理流程</h5><ul>
<li><p>PLIC会通知当前有一个待处理的中断</p>
</li>
<li><p>其中一个CPU核会Claim接收中断，这样PLIC就不会把中断发给其他的CPU处理</p>
</li>
<li><p>CPU核处理完中断之后，CPU会通知PLIC</p>
</li>
<li><p>PLIC将不再保存中断的信息</p>
</li>
</ul>
<p>PLIC只是分发中断，而内核需要<code>对PLIC进行编程</code>来告诉它中断应该分发到哪。实际上，内核可以对中断优先级进行编程，这里非常的灵活。</p>
<blockquote>
<p>例如对于xv6，这里的策略被编程为：所有的CPU都能收到中断，但是只有一个CPU会Claim相应的中断。</p>
</blockquote>
<h3 id="设备驱动概述"><a href="#设备驱动概述" class="headerlink" title="设备驱动概述"></a>设备驱动概述</h3><p>——管理外设的软件。我们今天要看的是UART设备的驱动</p>
<p>大部分驱动都分为两个部分，<code>bottom/top</code></p>
<h4 id="bottom"><a href="#bottom" class="headerlink" title="bottom"></a>bottom</h4><p>bottom部分通常是 <code>Interrupt handler</code>。CPU接收中断后会调用这个处理程序。<code>不运行在任何特定进程的context中</code>，单纯处理中断</p>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>top部分，是用户进程，或者内核的其他部分调用的接口</p>
</div><script src="https://jsd.cdn.zzko.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if("undefined"!=typeof lightGallery) {
        var options1 = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1);
        }</script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-08-15</span>
            
                <span>该篇文章被 Toki</span>
            
            
             
                <span>归为分类:
                    
                    
                        <a href='/categories/6-s081/'>
                            6.s081
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 2024 

            
                

            
                
                    / <a href="/contact/"> 联系 </a>
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>