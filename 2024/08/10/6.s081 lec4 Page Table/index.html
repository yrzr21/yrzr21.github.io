<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="lec4 Page Table" />
    <meta name="hexo-theme-A4" content="v1.9.2" />
    <link rel="alternate icon" type="image/webp" href="/img/logo.jpg">
    <title>Toki</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.2.0"></head>
    
    
        <style>
            .index-main{
                max-width:  880px;
            }
        </style>

    
    



    

    
    

    
    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #e4e4e4 ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/logo.jpg" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Toki</a> 
            <span class="description">Why so serious?</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
            
                <li><a href="/contact/">联系</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        
            
                <div class="post-main-title">
                    lec4 Page Table
                </div>
            
        
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Page-Table"><span class="post-toc-text">Page Table</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%AF%BE%E5%89%8D%E5%87%86%E5%A4%87"><span class="post-toc-text">课前准备</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Paging-hardware"><span class="post-toc-text">Paging hardware</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Sv39-RISC-V"><span class="post-toc-text">Sv39 RISC-V</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#translation-%E4%B8%8E-%E4%B8%89%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="post-toc-text">translation 与 三级页表</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#flags"><span class="post-toc-text">flags</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#satp-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="post-toc-text">satp 寄存器</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Kernel-address-space"><span class="post-toc-text">Kernel address space</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#QEMU-%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="post-toc-text">QEMU 计算机</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Code-creating-an-address-space"><span class="post-toc-text">Code: creating an address space</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#pagetable-t"><span class="post-toc-text">pagetable_t</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#walk%EF%BC%9AMMU"><span class="post-toc-text">walk：MMU</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#mappages"><span class="post-toc-text">mappages</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#kvm-uvm"><span class="post-toc-text">kvm &amp; uvm</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#copyout-copyin"><span class="post-toc-text">copyout &amp; copyin</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#PM-%E5%88%86%E9%85%8D"><span class="post-toc-text">PM 分配</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Code-Physical-memory-allocator"><span class="post-toc-text">Code: Physical memory allocator</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%88%86%E9%85%8D%E5%99%A8"><span class="post-toc-text">分配器</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#DRAM-%E6%95%B0%E9%87%8F"><span class="post-toc-text">DRAM 数量</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%8C%E9%87%8D%E7%94%A8%E9%80%94"><span class="post-toc-text">指针双重用途</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Process-address-space"><span class="post-toc-text">Process address space</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%8C%83%E5%9B%B4"><span class="post-toc-text">范围</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%88%86%E9%85%8D%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98"><span class="post-toc-text">分配进程内存</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%BF%9B%E7%A8%8B-VM-%E7%89%B9%E7%82%B9"><span class="post-toc-text">进程 VM 特点</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#initial-stack-%E4%B8%8E-guard-page"><span class="post-toc-text">initial stack 与 guard page</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Code-sbrk"><span class="post-toc-text">Code: sbrk</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Code-exec"><span class="post-toc-text">Code: exec</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#init-program-section-header"><span class="post-toc-text">&#x2F;init program section header</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Real-World"><span class="post-toc-text">Real World</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%A4%A7-page-%E4%B8%8E-%E5%B0%8F-page"><span class="post-toc-text">大 page 与 小 page</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="post-toc-text">内存分配</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%EF%BC%9AVM"><span class="post-toc-text">地址空间：VM</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="post-toc-text">隔离性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="post-toc-text">地址空间</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="post-toc-text">页表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="post-toc-text">工作机制</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%9C%B0%E5%9D%80%E5%A4%A7%E5%B0%8F"><span class="post-toc-text">地址大小</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#xv6%EF%BC%9A%E4%B8%89%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="post-toc-text">xv6：三级页表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E4%BC%98%E7%82%B9"><span class="post-toc-text">多级页表的优点</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81-walk-%E4%BA%8C%E6%AC%A1%E5%AE%9E%E7%8E%B0-MMU-%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="post-toc-text">为什么要 walk 二次实现 MMU 的功能？</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A1%AC%E4%BB%B6%E4%B8%8D%E5%BC%80%E5%8F%91%E7%B1%BB%E4%BC%BC%E4%BA%8Ewalk%E5%87%BD%E6%95%B0%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="post-toc-text">为什么硬件不开发类似于walk函数的接口？</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#flag"><span class="post-toc-text">flag</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8A%8APPN%E6%94%BE%E5%9C%A8%E4%B8%80%E4%B8%AAva%E4%B8%AD%EF%BC%9F"><span class="post-toc-text">为什么不把PPN放在一个va中？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%A1%B5%E8%A1%A8%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="post-toc-text">页表：虚拟化机制</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TLB%EF%BC%9A%E9%A1%B5%E8%A1%A8%E7%BC%93%E5%AD%98"><span class="post-toc-text">TLB：页表缓存</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BC%93%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="post-toc-text">缓存工作原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AD%A4%E5%A4%84%E7%9A%84%E7%BC%93%E5%AD%98%E7%BA%A7%E5%88%AB%E4%B8%BAPTE%E8%80%8C%E9%9D%9Epage%EF%BC%9F"><span class="post-toc-text">为什么此处的缓存级别为PTE而非page？</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%87%E6%8D%A2%E8%BF%9B%E7%A8%8B%EF%BC%9A%E6%B8%85%E7%A9%BATLB"><span class="post-toc-text">切换进程：清空TLB</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="post-toc-text">什么时候缓存？</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Kernel-%E9%A1%B5%E8%A1%A8"><span class="post-toc-text">Kernel 页表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="post-toc-text">物理地址空间</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#unmapped-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%EF%BC%9Aboot-ROM"><span class="post-toc-text">unmapped 物理内存：boot ROM</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#0x80000000%E4%B9%8B%E4%B8%8B%EF%BC%9ADRAM%E5%A4%96%E7%9A%84I-O%E8%AE%BE%E5%A4%87"><span class="post-toc-text">0x80000000之下：DRAM外的I&#x2F;O设备</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%9C%80%E4%B8%8A%E6%96%B9%E7%9A%84-Unused"><span class="post-toc-text">最上方的 Unused</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#XV6-%E5%86%85%E6%A0%B8%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="post-toc-text">XV6 内核地址空间</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#free-memory"><span class="post-toc-text">free memory</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#xv6-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">xv6 的实现</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#kvminit"><span class="post-toc-text">kvminit</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%88%86%E6%9E%90"><span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#kvminithart"><span class="post-toc-text">kvminithart</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#walk"><span class="post-toc-text">walk</span></a></li></ol></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="https://jsd.cdn.zzko.cn/npm/hexo-theme-a4@latest/source/css/lightgallery.min.css"><div class=".article-gallery"><h2 id="Page-Table"><a href="#Page-Table" class="headerlink" title="Page Table"></a>Page Table</h2><p>——实现 <em>VM到PM的映射</em>，提供 <em>强隔离性</em></p>
<h3 id="课前准备"><a href="#课前准备" class="headerlink" title="课前准备"></a>课前准备</h3><p>OS 通过页表实现 <em>VM到PM的映射</em>，使得不同进程使用独立的地址空间，提供<em>隔离性</em>，以及一些特殊的功能：</p>
<ol>
<li>不同进程共享内存：映射到同一PM<ul>
<li>mapping the same memory (a trampoline page) in several address spaces？</li>
</ul>
</li>
<li>保护栈：unmapped page</li>
</ol>
<h4 id="Paging-hardware"><a href="#Paging-hardware" class="headerlink" title="Paging hardware"></a>Paging hardware</h4><blockquote>
<p>The flags and all other page hardware-related structures are defined in (kernel&#x2F;riscv.h)</p>
</blockquote>
<ol>
<li>risc-v 指令操作的都是 va，而非pa</li>
<li>DRAM 通过 pa 索引</li>
<li>PT 提供 va 到 pa 的映射</li>
</ol>
<h5 id="Sv39-RISC-V"><a href="#Sv39-RISC-V" class="headerlink" title="Sv39 RISC-V"></a>Sv39 RISC-V</h5><p>（Supervisor Virtual）</p>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240809192703.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240809192703.png" class title="Pasted image 20240809192703.png"></a>


<ol>
<li><p>va：高 25bit 保留，va &#x3D; EXT+Index+Offset &#x3D; 25+27+12 &#x3D; ~+VPN+VPO</p>
<ul>
<li>共 $2^{27}$ 个 PTE，PTE &#x3D; PPN+flags &#x3D; 44+10</li>
<li>页粒度：$2^{12}$ B &#x3D; 4KB</li>
</ul>
</li>
<li><p>pa：低10bit保留，pa&#x3D; PPN+VPO+EXT &#x3D; 44+12+10</p>
</li>
</ol>
<h5 id="translation-与-三级页表"><a href="#translation-与-三级页表" class="headerlink" title="translation 与 三级页表"></a>translation 与 三级页表</h5><ol>
<li><p>risc-v 使用<em>三级页表</em>索引一个最终的PTE，每一级页表有 $2^{9}$ &#x3D; 512 个 PTE，占用空间一页（$2^{9+3}$ B）</p>
<ul>
<li>PTE 均索引物理页号</li>
</ul>
</li>
<li><p>任何页缺失，包括页表缺失，都会引发 <em>page-fault exception</em>，由 kernel 处理异常</p>
<ul>
<li>大部分VM并没有被映射，这是很常见的情况</li>
</ul>
</li>
<li><p>保留所有PT需要大量的内存，<em>三级页表使得只需保留很少一部分PT在内存中</em>，忽略没有被映射的页表</p>
</li>
</ol>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240809193645.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240809193645.png" class title="Pasted image 20240809193645.png"></a>

<h5 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h5><ul>
<li>V：指向的页是否合法&#x2F;被分配，索引未被分配的页会引发异常</li>
<li>RWX：页是否可读写，及从此加载指令</li>
<li>U：是否允许用户模式下的程序访问改页</li>
</ul>
<h5 id="satp-寄存器"><a href="#satp-寄存器" class="headerlink" title="satp 寄存器"></a>satp 寄存器</h5><p>存储<em>根页表的物理地址</em>，每个CPU都有自己的satp，可以更加方便快速地运行不同进程</p>
<h4 id="Kernel-address-space"><a href="#Kernel-address-space" class="headerlink" title="Kernel address space"></a>Kernel address space</h4><p>xv6 为<em>每个进程维护一个页表</em>，用于描述每个进程的用户地址空间，以及一个<em>描述内核地址空间的单独页表</em>：</p>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240809203658.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240809203658.png" class title="Pasted image 20240809203658.png"></a>

<ul>
<li>(kernel&#x2F;memlayout.h) 声明了 xv6 内核内存布局的常量。</li>
</ul>
<h5 id="QEMU-计算机"><a href="#QEMU-计算机" class="headerlink" title="QEMU 计算机"></a>QEMU 计算机</h5><p>QEMU 模拟了一个计算机</p>
<ol>
<li><p>物理内存： <em>0x80000000</em> 到至少 0x86400000 </p>
<ul>
<li>xv6 将0x86400000称为 <em>PHYSTOP</em></li>
</ul>
</li>
<li><p>QEMU 模拟还包括 I&#x2F;O 设备，将其接口暴露给软件，<em>通过读写 0x80000000 以下的物理内存与其交互</em></p>
<ul>
<li>接口例如例如磁盘接口</li>
<li>注意，与此地址交互时，是在与该硬件设备交互，而非RAM</li>
</ul>
</li>
<li><p><em>direct mapping</em>：va&#x3D;pa，简化读写物理内存和设备的代码</p>
</li>
<li><p>非直接映射页：</p>
<ul>
<li>trampoline page：映射在VM的顶部。用户页表也有这种页。<ul>
<li>一个物理页被映射两次：一次VM顶部，一次直接映射</li>
</ul>
</li>
<li>kernel stack pages &amp; guard page：映射在顶部，以在其下方有一个 valid bit 未设置的 guard page 以防止栈溢出</li>
</ul>
</li>
</ol>
<ul>
<li>权限 RX：trampoline and the kernel text</li>
<li>RW：其他</li>
<li>无效：guard</li>
</ul>
<h4 id="Code-creating-an-address-space"><a href="#Code-creating-an-address-space" class="headerlink" title="Code: creating an address space"></a>Code: creating an address space</h4><blockquote>
<p>The translations include the kernel’s instructions and data, physical memory up to PHYSTOP, and memory ranges which are actually devices. </p>
</blockquote>
<p>大部分用于操作地址空间和页表的 xv6 代码位于 <code>vm.c</code> 文件中（kernel&#x2F;vm.c:1）</p>
<ol>
<li><p>risc-v 启动时，main 调用 kvminit 创建内核页表，此过程发生在启用分页前，其地址直接映射到物理地址</p>
</li>
<li><p>main 调用 kvminithart 将根页表放入 satp 寄存器并启用分页。自此有了分页功能，但现有的vm直接映射到pm</p>
</li>
<li><p>main 调用 procinit 将所有进程的内核栈指针指向 KSTACK 生成的虚拟地址，从而为 guard page 预留空间</p>
</li>
</ol>
<h5 id="pagetable-t"><a href="#pagetable-t" class="headerlink" title="pagetable_t"></a>pagetable_t</h5><p>指向根页表的指针</p>
<h5 id="walk：MMU"><a href="#walk：MMU" class="headerlink" title="walk：MMU"></a>walk：MMU</h5><p>模拟 MMU 查找 va 对应的最终的 PTE 的地址：</p>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240809193645.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240809193645.png" class title="Pasted image 20240809193645.png"></a>

<p>每9位下降到下一级页表直到最终的PTE，如果中间页表的 PTE 无效 且 alloc 参数被设置，则分配一个物理页，直到最低层</p>
<ul>
<li>MMU 在 TLB 中缓存 PTE。修改某个PTE时，CPU必须通知 TLB 某个 PTE 为 dirty 失效。</li>
<li>通过 sfence_vma 刷新当前CPU的 TLB</li>
</ul>
<h5 id="mappages"><a href="#mappages" class="headerlink" title="mappages"></a>mappages</h5><p>按页大小对齐为范围内的每对 va &amp; pa 创建 PTE</p>
<p>调用 walk 找到 PTE，然后初始化 PTE 存储 PPN、权限位、以及 PTE_V</p>
<h5 id="kvm-uvm"><a href="#kvm-uvm" class="headerlink" title="kvm &amp; uvm"></a>kvm &amp; uvm</h5><p>分别操作内核和用户页表，其余函数两者都用</p>
<ul>
<li>kvminit：先分配物理页保存根页表，然后调用 kvmmap 创建 PTE。</li>
<li>kvmmap：只在启动时使用，调用mappages 创建 PTE</li>
<li>kvminithart：将根页表放入 satp 寄存器并启用分页。现有的vm直接映射到pm<ul>
<li>在 kvminithart 加载satp后 刷新</li>
<li>在返回用户空间前、切换用户页表时刷新 kernel&#x2F;trampoline.S</li>
</ul>
</li>
</ul>
<h5 id="copyout-copyin"><a href="#copyout-copyin" class="headerlink" title="copyout &amp; copyin"></a>copyout &amp; copyin</h5><p>在用户虚拟地址和内核之间复制数据</p>
<h4 id="PM-分配"><a href="#PM-分配" class="headerlink" title="PM 分配"></a>PM 分配</h4><ol>
<li><p>对象：页表、用户内存、内核栈和管道缓冲区</p>
</li>
<li><p>范围：内核末尾 and PHYSTOP</p>
</li>
<li><p>大小：一页，即 4KB</p>
</li>
</ol>
<p>使用链表跟踪空闲页，分配即从该链表中移除空闲页，释放即插入到该链表中</p>
<h4 id="Code-Physical-memory-allocator"><a href="#Code-Physical-memory-allocator" class="headerlink" title="Code: Physical memory allocator"></a>Code: Physical memory allocator</h4><blockquote>
<p>kernel&#x2F;kalloc.c:1</p>
</blockquote>
<h5 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h5><p>分配器使用自旋锁保护：</p>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810071704.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810071704.png" class title="Pasted image 20240810071704.png"></a>

<p>列表元素：</p>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810071904.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810071904.png" class title="Pasted image 20240810071904.png"></a>

<ol>
<li><p>main 调用 <em>kinit</em> 来初始化 freelist，以容纳从内核末尾到 PHYSTOP 之间的每个 page</p>
</li>
<li><p>kinit 调用 <em>freerange</em> 通过释放，将这些page 添加到 freelist 中</p>
</li>
<li><p>freerange 使用 <em>PGROUNDUP</em> 确保只释放对其的物理内存</p>
<ul>
<li>PTE 只能引用 4KB 对齐的物理内存</li>
</ul>
</li>
<li><p>freerange 调用 <em>kfree</em> 释放单个页：</p>
<ul>
<li>将被释放页的每个字节设为1，也即是 <em>垃圾值</em>，希望这样能使代码崩溃</li>
<li>然后将 pa* 转化为 run*，插入到 freelist 中</li>
</ul>
</li>
<li><p>使用 <em>kalloc</em> 分配内存时，即删除 freelist 所指向的第一个页</p>
</li>
</ol>
<h5 id="DRAM-数量"><a href="#DRAM-数量" class="headerlink" title="DRAM 数量"></a>DRAM 数量</h5><p>本应通过解析硬件提供的配置信息来确定可用的物理内存数量，但 xv6 假设机器有 128MB 的RAM</p>
<h5 id="指针双重用途"><a href="#指针双重用途" class="headerlink" title="指针双重用途"></a>指针双重用途</h5><ol>
<li><p>分配器有时将地址视为<em>整数</em>，以便对其执行算术运算，如<em>遍历</em></p>
</li>
<li><p>指针</p>
</li>
</ol>
<p>所以充满着C类型转换</p>
<h4 id="Process-address-space"><a href="#Process-address-space" class="headerlink" title="Process address space"></a>Process address space</h4><p>每个进程都有独立的页表，在切换进程时也会切换页表</p>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810080807.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810080807.png" class title="Pasted image 20240810080807.png"></a>

<h5 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h5><p>进程的 VM 范围为：0~<em>MAXVA</em>，原则上允许一个进程寻址 256GB 的内存</p>
<ul>
<li>kernel&#x2F;riscv.h:348</li>
</ul>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810080256.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810080256.png" class title="Pasted image 20240810080256.png"></a>

<h5 id="分配进程内存"><a href="#分配进程内存" class="headerlink" title="分配进程内存"></a>分配进程内存</h5><p>进程请求分配用户内存是，xv6 使用kalloc分配物理页，然后创建 PTE、设置包含PTE_V的权限位</p>
<h5 id="进程-VM-特点"><a href="#进程-VM-特点" class="headerlink" title="进程 VM 特点"></a>进程 VM 特点</h5><ol>
<li><em>隔离性</em>：用户间的页表独立，可以映射到不同的物理内存</li>
<li>进程视角的内存 VM 是<em>连续</em>的，而它实际的 PM 可以<em>不连续</em></li>
<li>顶部有一个页存放 trampoline code，thus a single page of physical memory shows up in all address spaces.？？？</li>
</ol>
<h5 id="initial-stack-与-guard-page"><a href="#initial-stack-与-guard-page" class="headerlink" title="initial stack 与 guard page"></a>initial stack 与 guard page</h5><p>见上图。下方有一个 guard page 防止栈溢出，访问此页时会引发异常 <em>page-fault exception</em>。</p>
<ul>
<li>真实的操作系统可能会有别的操作，比如访问 guard page 时为进程分配更多内存</li>
</ul>
<h4 id="Code-sbrk"><a href="#Code-sbrk" class="headerlink" title="Code: sbrk"></a>Code: sbrk</h4><blockquote>
<p>growproc、uvmdealloc、uvmalloc：kernel&#x2F;proc.c</p>
</blockquote>
<ol>
<li><p><em>Sbrk</em> 是一个系统调用，用于<em>进程缩小或扩展其内存</em>，通过调用 <em>growproc</em> 实现</p>
</li>
<li><p>growproc 根据传入的 n 的正负调用 uvmalloc 或 uvmdealloc</p>
<ul>
<li><em>uvmalloc</em> 调用 kalloc 分配物理内存，并调用 mappages 创建 PTE</li>
<li><em>uvmdealloc</em> 调用 uvmunmap，后者使用 walk 查找 PTE 从而找到 pa，然后调用 kfree 释放内存</li>
</ul>
</li>
</ol>
<p>——页表是唯一记录进程已分配 PM 的方式</p>
<h4 id="Code-exec"><a href="#Code-exec" class="headerlink" title="Code: exec"></a>Code: exec</h4><blockquote>
<p>kernel&#x2F;exec.c<br>ELF：kernel&#x2F;elf.h</p>
</blockquote>
<p>根据文件系统上的某个文件初始化用户部分的地址空间：</p>
<blockquote>
<p>打开文件，读取并根据 magic 检查ELF头，确定well-formed 后，创建新页表、分配物理内存、加载每个段到内存中。然后复制exec参数到栈顶，释放旧映像并返回</p>
</blockquote>
<ol>
<li><p>调用 <em>namei</em> 打开文件，然后通过 <em>readi</em> 读取文件的 <em>ELF 头</em> elfhdr，以及 <em>程序段头</em> proghdr </p>
<ul>
<li>ELF 头描述了程序的一些基本信息，而程序段头描述了必须加载到内存中的程序段</li>
<li>xv6 程序只有一个程序段头，但其他系统可能会为指令和数据设置单独的段。</li>
</ul>
</li>
<li><p>exec 会检查 ELF 开头的 <em>magic number</em>，若具有则假定文件具有完整的二进制格式 well-formed</p>
<ul>
<li>magic number：0x7F, ‘E’, ‘L’, ‘F’, or ELF_MAGIC</li>
</ul>
</li>
<li><p>使用 proc.c 中的 <em>proc_pagetable</em> 为进程创建全新的页表，并使用 <em>uvmalloc</em> 为每个ELF段分配物理内存，然后使用 <em>loadseg</em> 将每个段加载到内存中</p>
<ul>
<li>loadseg 使用 walkaddr 检索到va对应的pa</li>
</ul>
</li>
<li><p>此时以及分配好了栈页，但只为栈分配了一页。exec 将字符串逐个<em>复制到栈顶</em>，并在 ustack 中记录他们的指针，并在其末尾放置一个空指针。最终 ustack 的前三个条目是 fake PC、argc、argv</p>
</li>
<li><p>exec 在堆栈下放了一个 <em>guard page</em>，禁止栈溢出，使用多于其本身大小（1 page）的内存。</p>
<ul>
<li>这还允许 exec 处理数量过多的参数，copyout 会返回-1</li>
</ul>
</li>
<li><p>准备文件的新内存映像 <em>memory image</em> 时，如果遇到无效程序段，会<em>释放</em>新映像并返回-1。</p>
<ul>
<li>这意味着 exec 必须等新映像成功创建后才可以释放旧映像</li>
<li>创建成功后即可切换到新页表并释放旧映像</li>
</ul>
</li>
<li><p><em>安全问题</em>：exec 将ELF文件中的字节复制到指定的 va 中，这是有风险的：如果指向内核会造成崩溃</p>
<ul>
<li>xv6 执行了许多检查以避免这些风险，例如，<code>if(ph.vaddr + ph.memsz &lt; ph.vaddr)</code> 检查总和是否溢出 64 位整数</li>
<li>旧的 xv6 用户地址空间包含内核但不可读写，程序可利用这个漏洞攻击内核。RISC-V 版本下内核有单独的页表，loadseg 只会把数据加载到进程的页表中，而非内核的页表中</li>
</ul>
</li>
</ol>
<h5 id="init-program-section-header"><a href="#init-program-section-header" class="headerlink" title="/init program section header"></a>/init program section header</h5><a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810102741.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810102741.png" class title="Pasted image 20240810102741.png"></a>

<p>filesz 可能小于 memsz，其间隙应该用0填充，而非从文件读取数据</p>
<ul>
<li>memsz：段被分配的实际PM大小</li>
<li>filesz：该文件的实际大小</li>
</ul>
<h4 id="Real-World"><a href="#Real-World" class="headerlink" title="Real World"></a>Real World</h4><blockquote>
<p>与大多数操作系统一样，xv6 使用<em>分页硬件</em>来实现内存保护和映射。大多数操作系统通过结合<em>分页和 page-fault exceptions</em> 来实现更复杂的分页功能，而 xv6 相对简化了这些操作。</p>
</blockquote>
<p>xv6 使用 va-pa 的 <em>直接映射</em> 简化内存操作，并假设在 <code>0x8000000</code> 处存在RAM，期望内核在此处被加载</p>
<ul>
<li>实际硬件应将RAM和设备放在不可预测的物理地址处</li>
<li>成熟的内核设计利用页表将任意物理内存布局转化为可预测的内核虚拟地址布局</li>
<li>RISC-V 支持PM级保护，而xv6没有这一特性</li>
</ul>
<h5 id="大-page-与-小-page"><a href="#大-page-与-小-page" class="headerlink" title="大 page 与 小 page"></a>大 page 与 小 page</h5><ol>
<li><p>在内存较大的机器上，使用 RISC-V 的 <em>super pages</em> 完全ok</p>
</li>
<li><p>而小页允许以更精细的粒度分配物理内存、写入磁盘</p>
</li>
</ol>
<h5 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h5><p>xv6 内核缺乏类似 malloc 的可以为小对象分配内存的分配器，也就无需为动态分配内存准备复杂的数据结构</p>
<p>内存分配一直是热门话题，其基本问题是如何有效利用有限的内存，并为未知的未来请求做好准备。如今，人们更关心速度而非空间效率。此外，一个更复杂的内核可能会分配许多不同大小的小块内存，而不仅仅是像 xv6 那样只分配 4096 字节的块；现实中的内核分配器需要<em>同时处理小规模和大规模的分配</em>。</p>
<h3 id="地址空间：VM"><a href="#地址空间：VM" class="headerlink" title="地址空间：VM"></a>地址空间：VM</h3><p>一种隔离性实现方式：地址空间</p>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>期望每个用户程序<em>不会相互影响、也不会影响 OS</em></p>
<h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><p>给包括内核在内的所有程序<em>专属独立的地址空间</em>，也就不能引用任何不属于自己的内存</p>
<ul>
<li>这样，程序若想向地址1000写入数据就只会写入自己地址空间的1000，而不会影响其他进程</li>
</ul>
<p>所以现在我们的问题是 <em>如何在一个物理内存上，创建不同的地址空间</em>，最常见的方法就是 <em>页表</em></p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>页表通过 <em>处理器 + MMU</em> 实现，处理器将 va 发送给 MMU，MMU 将 va 翻译为 pa 后索引 PM，然后向物理内存读写数据</p>
<ul>
<li>内存管理单元（Memory Management Unit）</li>
<li>CPU 使用的全部都是虚拟地址</li>
</ul>
<p>为了将 va 翻译为 pa，需要有一个表单<em>存储映射关系</em>，即 <em>页表</em></p>
<p><em>PT 通常来说也存储在内存中</em>，也因此CPU中需要有<em>寄存器 satp 存储页表的 pa</em>，从而可以告诉 MMU 从哪里找 PT</p>
<ul>
<li>MMU不会保存PT，不会创建PT，无法翻译地址时告诉CPU发生错误</li>
<li>切换进程时需要切换PT，此时需要修改 satp 的值</li>
</ul>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/image%2016.avif" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/image%2016.avif" class title="image 16.avif"></a>


<h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><p>如果为64位机器的每一个地址都存储一个 PTE，那么需要耗费海量的空间存储 PT，实际情况中，RISC-V<em>为每个 page 存储一个 PTE</em>，<em>粒度为 4KB</em>，$2^{12}$ B</p>
<ul>
<li>4KB大小的page，也就是说<em>需要12个比特索引</em></li>
<li>页内部连续</li>
</ul>
<p>我们将va分为两部分：<em>index &amp; offset</em>，<em>使用index查找page，offset 索引具体的字节</em></p>
<p>index 标识了物理内存的页号，MMU 通过 VPN 读取 PT 中的 PPN，也就是物理页号，PPN + VPO 共同组成了具体地址的指针</p>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810120824.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810120824.png" class title="Pasted image 20240810120824.png"></a>
<h4 id="地址大小"><a href="#地址大小" class="headerlink" title="地址大小"></a>地址大小</h4><p>va 的<em>高25位没有使用</em>，限制了VM的大小，那么现在一个进程的 VM 只有 $2^{39}$ B &#x3D; 512 GB</p>
<ul>
<li>新的处理器或许可以支持更大的地址空间，只需要将未使用的25bit拿出来做为虚拟内存地址的一部分即可</li>
</ul>
<p>va &#x3D; index + offset &#x3D; 39 &#x3D; 27 + 12，pa &#x3D; PPN + VPO &#x3D; 56 &#x3D; <em>44 + 12</em></p>
<ul>
<li>大多数主板还不支持2^56这么大的物理内存，但是原则上，如果你能造出这样的主板，那么最多可以支持2^56字节的物理内存</li>
<li>PPO &#x3D; VPO，所以此处直接用了VPO</li>
<li>56位的物理内存是设计人员决定的，他们预测物理内存在5年内不可能超过2^56这么大。<em>主板上这时候只需要56根线</em></li>
</ul>
<p>这样的大小设计允许有<em>多个进程用光了虚拟内存，而物理内存完全还有冗余可以分配</em></p>
<p>index有27位，也就是说每个PT最多有2^27个条目，但这同样会消耗大量的内存，实际中使用<em>多级页表</em>减小 PT 的大小</p>
<h4 id="xv6：三级页表"><a href="#xv6：三级页表" class="headerlink" title="xv6：三级页表"></a>xv6：三级页表</h4><p>index &#x3D; L2+L1+L0 &#x3D; 9+9+9，最高9位的L2用于索引最高级的页表 page directory，每个PT的<em>PPN要么指向下级页表的页号，要么指向最终数据的页号</em></p>
<ul>
<li>page table，page directory， page directory table 可以都当作 PT</li>
<li><em>最高级页表的页号后面跟9+9+12个0就是L1页表的物理地址</em>，其余同理</li>
<li>三级页表查找由<em>硬件实现</em>。在XV6软件中，函数<em>walk</em>也实现了相同的功能</li>
</ul>
<p>一个directory同样用一页存储，大小为4KB。一个PTE 8B &#x3D; 2^3 B，共512&#x3D;2^9个PTE</p>
<p>SATP 实际存储根页表的物理地址</p>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810122939.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810122939.png" class title="Pasted image 20240810122939.png"></a>

<h5 id="多级页表的优点"><a href="#多级页表的优点" class="headerlink" title="多级页表的优点"></a>多级页表的优点</h5><p>所以这种3步得到物理地址的方式的<em>优点是什么？</em></p>
<p>大多数进程只需要一个三级页表，即三个PT，约12KB的内存，索引 $2^{9+12}$ B &#x3D; 2MB 的物理内存，而大部分内存是尚未被分配的，我们完全不需要为这些va分配PTE并存储到PT中</p>
<h5 id="为什么要-walk-二次实现-MMU-的功能？"><a href="#为什么要-walk-二次实现-MMU-的功能？" class="headerlink" title="为什么要 walk 二次实现 MMU 的功能？"></a>为什么要 walk 二次实现 MMU 的功能？</h5><p>首先XV6中的walk函数设置了最初的page table，它需要对3级page table进行编程所以它首先需要能模拟3级page table。</p>
<ul>
<li>？？？</li>
</ul>
<p>其次，内核和进程都有自己的页表，无法访问对方的物理内存，此时内核需要访问对方的页表以获得一个自己可以读写的用户数据所在的物理内存…所以需要 walk 实现 MMU 的功能</p>
<h5 id="为什么硬件不开发类似于walk函数的接口？"><a href="#为什么硬件不开发类似于walk函数的接口？" class="headerlink" title="为什么硬件不开发类似于walk函数的接口？"></a>为什么硬件不开发类似于walk函数的接口？</h5><p>后面会说</p>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810135622.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810135622.png" class title="Pasted image 20240810135622.png"></a>



<h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810125144.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810125144.png" class title="Pasted image 20240810125144.png"></a>

<p>前面有，最重要的几个标志位是：VRWXU</p>
<h4 id="为什么不把PPN放在一个va中？"><a href="#为什么不把PPN放在一个va中？" class="headerlink" title="为什么不把PPN放在一个va中？"></a>为什么不把PPN放在一个va中？</h4><p>我们要查物理地址就需要通过PPN，而若把PPN放在va中，则我们可能需要查这个va的PPN，进而陷入无限的递归——这样做完全没有必要，反而浪费了时间</p>
<p>SATP也是同理，我们需要存放物理地址</p>
<h4 id="页表：虚拟化机制"><a href="#页表：虚拟化机制" class="headerlink" title="页表：虚拟化机制"></a>页表：虚拟化机制</h4><p>page table提供了一层 level of indirecton，映射关系由OS完全掌控，可以实现各种各样的功能</p>
<ul>
<li>例如：当出现page fault的时候，操作系统可以做哪些有意思的事情</li>
</ul>
<p>改变用户所看见的视图，提供了非常大的灵活性</p>
<h3 id="TLB：页表缓存"><a href="#TLB：页表缓存" class="headerlink" title="TLB：页表缓存"></a>TLB：页表缓存</h3><p>每次与内存交互都要查三次页表，这看起来代价很高，实际中可以通过<em>缓存</em>解决这个问题，也即我们所说的页表项PTE的缓存 Translation Lookside Buffer TLB</p>
<h4 id="缓存工作原理"><a href="#缓存工作原理" class="headerlink" title="缓存工作原理"></a>缓存工作原理</h4><p>CPU传递va给MMU 时，MMU 首先查看TLB看看有没有缓存这个PTE。命中则与内存交互得到数据返回给CPU；否则与内存交互查询PT得到PTE，并与内存交互得到数据返回给CPU</p>
<h5 id="为什么此处的缓存级别为PTE而非page？"><a href="#为什么此处的缓存级别为PTE而非page？" class="headerlink" title="为什么此处的缓存级别为PTE而非page？"></a>为什么此处的缓存级别为PTE而非page？</h5><blockquote>
<p>有很多种方法都可以实现TLB，对于你们来说最重要的是知道TLB是存在的。TLB实现的具体细节不是我们要深入讨论的内容。这是处理器中的一些逻辑，对于操作系统来说是不可见的，操作系统也不需要知道TLB是如何工作的。</p>
</blockquote>
<h4 id="切换进程：清空TLB"><a href="#切换进程：清空TLB" class="headerlink" title="切换进程：清空TLB"></a>切换进程：清空TLB</h4><blockquote>
<p>你们需要知道TLB存在的唯一原因是，如果你切换了page table，操作系统需要告诉处理器当前正在<em>切换page table，处理器会清空TLB</em>。为本质上来说，如果你切换了page table，TLB中的缓存将不再有用，它们需要被清空，否则地址翻译可能会出错。</p>
</blockquote>
<p>清空指令：sfence_vma</p>
<h4 id="什么时候缓存？"><a href="#什么时候缓存？" class="headerlink" title="什么时候缓存？"></a>什么时候缓存？</h4><p>整个CPU和MMU都在处理器芯片中，所以在一个RISC-V芯片中有多个CPU核，MMU和TLB存在于每一个CPU核里面。</p>
<p>RISC-V处理器有L1 cache，L2 Cache，有些cache是根据物理地址索引的，有些cache是根据虚拟地址索引的，<em>由虚拟地址索引的cache位于MMU之前，由物理地址索引的cache位于MMU之后</em>。</p>
<h3 id="Kernel-页表"><a href="#Kernel-页表" class="headerlink" title="Kernel 页表"></a>Kernel 页表</h3><p>kernel 地址空间：</p>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810140036.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810140036.png" class title="Pasted image 20240810140036.png"></a>

<h4 id="物理地址空间"><a href="#物理地址空间" class="headerlink" title="物理地址空间"></a>物理地址空间</h4><p>右半部分的<em>结构完全由硬件设计者决定</em>，他们决定如果物理地址大于 <em>0x80000000</em> 会走向DRAM芯片，如果得到的物理地址低于0x80000000会走向不同的I&#x2F;O设备</p>
<ul>
<li>至于是哪个IO设备可以查看主板的手册</li>
</ul>
<p>例如，地址0是保留的，地址0x10090000对应以太网，地址0x80000000对应DRAM。</p>
<blockquote>
<p>以下内容基于QEMU模拟的计算机</p>
</blockquote>
<h5 id="unmapped-物理内存：boot-ROM"><a href="#unmapped-物理内存：boot-ROM" class="headerlink" title="unmapped 物理内存：boot ROM"></a>unmapped 物理内存：boot ROM</h5><p>此部分主要包含boot ROM，其结构为：未使用–boot ROM–未使用</p>
<p><em>当你对主板上电，主板做的第一件事情就是运行存储在boot ROM中的代码，当boot完成之后，会跳转到地址0x80000000</em>，OS需要确保这个地址有一些数据以启动 OS</p>
<h5 id="0x80000000之下：DRAM外的I-O设备"><a href="#0x80000000之下：DRAM外的I-O设备" class="headerlink" title="0x80000000之下：DRAM外的I&#x2F;O设备"></a>0x80000000之下：DRAM外的I&#x2F;O设备</h5><p>主要分为：中断控制器、Concole和显示器交互、与磁盘交互</p>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810141205.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810141205.png" class title="Pasted image 20240810141205.png"></a>

<p>我们向这些 “<em>虚拟的物理内存</em>” 读写即是在与实际设备交互，包括与DRAM物理内存的交互也是被虚拟化后的，实际的DRAM可不是一个大数组，<em>这是一层抽象</em></p>
<h5 id="最上方的-Unused"><a href="#最上方的-Unused" class="headerlink" title="最上方的 Unused"></a>最上方的 Unused</h5><p>——DRAM不够了，这部分物理内存没被覆盖到</p>
<p>xv6 中设置为128MB</p>
<h4 id="XV6-内核地址空间"><a href="#XV6-内核地址空间" class="headerlink" title="XV6 内核地址空间"></a>XV6 内核地址空间</h4><ol>
<li><p>内核地址空间的映射大多数都是 <em>恒等映射：从最底部的设备到PHYSTOP</em></p>
</li>
<li><p><em>内核栈在VM中的位置很靠后</em>，这是为了在其后放置一个 <em>guard page</em>，以防止栈溢出</p>
<ul>
<li>Guard page的PTE中Valid标志位未设置，会导致立即触发page fault</li>
<li>也就是说，guard page 未被映射到任何物理地址，它只是占据了虚拟地址空间的一段靠后的地址。</li>
</ul>
</li>
<li><p><em>kernel stack 被映射了两次</em>，在 <em>靠后的虚拟地址</em> 映射了一次，在PHYSTOP下的<em>Kernel data</em>中又映射了一次</p>
<ul>
<li>Kernel data 段中无 guard page</li>
<li>实际使用的时候用的是上面的部分，因为有Guard page会更加安全</li>
<li>每一个用户进程都有一个对应的kernel stack</li>
</ul>
</li>
<li><p>通过设置 <em>权限</em> 我们可以尽早的发现Bug从而避免Bug</p>
<ul>
<li>Kernel text page：R-X</li>
<li>Kernel data page：RW-</li>
</ul>
</li>
</ol>
<h5 id="free-memory"><a href="#free-memory" class="headerlink" title="free memory"></a>free memory</h5><p>存储用户进程的 PT、text、data，耗尽时 fork 和 exec 会返回错误</p>
<p>理论上来说用户和内核的虚拟地址空间大小一样，但是用户的VM使用率更低</p>
<h3 id="xv6-的实现"><a href="#xv6-的实现" class="headerlink" title="xv6 的实现"></a>xv6 的实现</h3><h4 id="kvminit"><a href="#kvminit" class="headerlink" title="kvminit"></a>kvminit</h4><p><em>设置 kernel 地址空间</em></p>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810164811.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810164811.png" class title="Pasted image 20240810164811.png"></a>

<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810164852.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810164852.png" class title="Pasted image 20240810164852.png"></a>

<ol>
<li><p>先为最高级页表分配物理页，并初始化为全0</p>
</li>
<li><p>通过 <em>kvmmap</em> 为每一个 I&#x2F;O 设备创建 PTE，其 va 和 pa 由宏定义的值指定</p>
<ul>
<li>memlayout.h</li>
<li>由代码可见，这是恒等映射&#x2F;直接映射</li>
</ul>
</li>
</ol>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>执行完第一个kvmmap时的kernel page table：</p>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810171537.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810171537.png" class title="Pasted image 20240810171537.png"></a>

<ol>
<li><p>最高级页表位于 0x87fff000，只有一个页表项，其序号为0</p>
</li>
<li><p>中间页表位于<del>，只有一个页表项，其序号为128。最低级的页表</del>，最终指向 UART0，即 0x10000000L，即：000000000 010000000 000000000 000000000000</p>
</li>
</ol>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810172244.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810172244.png" class title="Pasted image 20240810172244.png"></a>

<ul>
<li>0x10000000L 右移12位为VPN，再右移九位为二级页表的序号128（因为最高级页表序号为0）</li>
</ul>
<ol start="3">
<li>根据 fl 部分可确定标志位，图中最低级PTE的标志为：0x7 &#x3D; 0111，即：WRV，这意味着合法可读写，不可执行不可用户访问等等</li>
</ol>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810125144.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810125144.png" class title="Pasted image 20240810125144.png"></a>








<h4 id="kvminithart"><a href="#kvminithart" class="headerlink" title="kvminithart"></a>kvminithart</h4><a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810172917.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810172917.png" class title="Pasted image 20240810172917.png"></a>

<ol>
<li><p>设置 SATP 寄存器，使用 kvminit 刚设置好的页表——我们现在有了分页机制</p>
<ul>
<li>此前用的是物理地址，此后使用的全都是虚拟地址</li>
<li>内核的映射基本全都是恒等映射，经过地址翻译0x80001110还是对应0x80001110。</li>
<li>切换进程时需要切换页表，一旦 SATP 设置错了，其结果是，要么覆盖掉别的数据进而造成奇怪的错误，要么访问到非法page产生 page fault</li>
</ul>
</li>
<li><p>然后刷新 TLB</p>
</li>
</ol>
<h4 id="walk"><a href="#walk" class="headerlink" title="walk"></a>walk</h4><p><em>模拟MMU进行地址翻译，返回 va 对应的 PTE 的指针</em></p>
<ul>
<li>没有 TLB 这样的专门缓存</li>
</ul>
<p>在翻译过程中，如果中间PTE不存在，若alloc被设置，则会分配一个临时的PTE初始化为0，并继续执行，否则直接返回0</p>
<p><em>即便有了分页机制，walk函数还能正常工作，这正是因为恒等映射</em></p>
<a href="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810174003.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/10/6.s081%20lec4%20Page%20Table/Pasted%20image%2020240810174003.png" class title="Pasted image 20240810174003.png"></a>



</div><script src="https://jsd.cdn.zzko.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if("undefined"!=typeof lightGallery) {
        var options1 = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1);
        }</script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-08-10</span>
            
                <span>该篇文章被 Toki</span>
            
            
             
                <span>归为分类:
                    
                    
                        <a href='/categories/6-s081/'>
                            6.s081
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 2024 

            
                

            
                
                    / <a href="/contact/"> 联系 </a>
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>