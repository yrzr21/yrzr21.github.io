<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="lec9 Interrupts and Device Drivers" />
    <meta name="hexo-theme-A4" content="v1.9.2" />
    <link rel="alternate icon" type="image/webp" href="/img/logo.jpg">
    <title>Toki</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.2.0"></head>
    
    
        <style>
            .index-main{
                max-width:  880px;
            }
        </style>

    
    



    

    
    

    
    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #e4e4e4 ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/logo.jpg" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Toki</a> 
            <span class="description">Why so serious?</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
            
                <li><a href="/contact/">联系</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        
            
                <div class="post-main-title">
                    lec9 Interrupts and Device Drivers
                </div>
            
        
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Interrupts-and-Device-Drivers"><span class="post-toc-text">Interrupts and Device Drivers</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%AF%BE%E5%89%8D%E5%87%86%E5%A4%87"><span class="post-toc-text">课前准备</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Code-Console-input"><span class="post-toc-text">Code: Console input</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#UART%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="post-toc-text">UART：控制寄存器</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#consoleinit"><span class="post-toc-text">consoleinit</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#shell-%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5"><span class="post-toc-text">shell 读取输入</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#devintr"><span class="post-toc-text">devintr</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#uartintr-%E4%B8%8E-consoleintr"><span class="post-toc-text">uartintr 与 consoleintr</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Code-Console-output"><span class="post-toc-text">Code: Console output</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E-uartputc"><span class="post-toc-text">输出缓冲区与 uartputc</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AE%8C%E6%88%90%E4%B8%AD%E6%96%AD%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="post-toc-text">完成中断与输出</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%AE%BE%E5%A4%87%E6%B4%BB%E5%8A%A8%E4%B8%8E%E8%BF%9B%E7%A8%8B%E6%B4%BB%E5%8A%A8%E7%9A%84%E8%A7%A3%E8%80%A6"><span class="post-toc-text">设备活动与进程活动的解耦</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Concurrency-in-drivers"><span class="post-toc-text">Concurrency in drivers</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Timer-interrupts"><span class="post-toc-text">Timer interrupts</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Timer-interrupts%EF%BC%9A%E6%9C%BA%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">Timer interrupts：机器模式</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#main%E4%B9%8B%E5%89%8D%EF%BC%9Astart"><span class="post-toc-text">main之前：start</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8F%91%E7%94%9F%E6%97%B6%E6%9C%BA"><span class="post-toc-text">发生时机</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#timervec"><span class="post-toc-text">timervec</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Real-World"><span class="post-toc-text">Real World</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="post-toc-text">定时器带来的复杂性</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%B9%81%E9%87%8D%E6%80%A7"><span class="post-toc-text">驱动程序的繁重性</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%8C%96I-O-%E4%B8%8E-DMA"><span class="post-toc-text">程序化I&#x2F;O 与 DMA</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%89%B9%E9%87%8F%E4%B8%AD%E6%96%AD"><span class="post-toc-text">批量中断</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#UART-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%8C%E9%87%8D%E5%A4%8D%E5%88%B6"><span class="post-toc-text">UART 驱动程序的双重复制</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%9C%9F%E5%AE%9E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="post-toc-text">真实操作系统内存使用情况</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Interrupt-%E7%A1%AC%E4%BB%B6%E9%83%A8%E5%88%86"><span class="post-toc-text">Interrupt 硬件部分</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E7%89%B9%E7%82%B9"><span class="post-toc-text">中断的特点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BB%8E%E5%93%AA%E9%87%8C%E4%BA%A7%E7%94%9F%EF%BC%9F"><span class="post-toc-text">中断从哪里产生？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#PLIC"><span class="post-toc-text">PLIC</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#PLIC-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="post-toc-text">PLIC 中断处理流程</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A6%82%E8%BF%B0"><span class="post-toc-text">设备驱动概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%A9%B1%E5%8A%A8%E7%BB%84%E6%88%90%EF%BC%9Abottom%E3%80%81top-%E4%B8%8E%E9%98%9F%E5%88%97"><span class="post-toc-text">驱动组成：bottom、top 与队列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Interrupt-handler%EF%BC%9A%E9%99%90%E5%88%B6"><span class="post-toc-text">Interrupt handler：限制</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AF%B9%E8%AE%BE%E5%A4%87%E7%BC%96%E7%A8%8B%EF%BC%9Amemory-mapped-I-O"><span class="post-toc-text">对设备编程：memory mapped I&#x2F;O</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#SiFive%E4%B8%BB%E6%9D%BF"><span class="post-toc-text">SiFive主板</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#UART-%E6%96%87%E6%A1%A3"><span class="post-toc-text">UART 文档</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9C%A8XV6%E4%B8%AD%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%AD"><span class="post-toc-text">在XV6中设置中断</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8"><span class="post-toc-text">中断寄存器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#xv6%EF%BC%9A%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%AD"><span class="post-toc-text">xv6：配置中断</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%BB%8E-start-%E5%88%B0-uartinit"><span class="post-toc-text">从 start 到 uartinit</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#uartinit%EF%BC%9A%E9%85%8D%E7%BD%AEuart"><span class="post-toc-text">uartinit：配置uart</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#plicinit%EF%BC%9A%E9%85%8D%E7%BD%AEPLIC"><span class="post-toc-text">plicinit：配置PLIC</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#plicinithart%EF%BC%9A%E9%85%8D%E7%BD%AECPU"><span class="post-toc-text">plicinithart：配置CPU</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#scheduler%EF%BC%9A%E8%BF%90%E8%A1%8C%E8%BF%9B%E7%A8%8B"><span class="post-toc-text">scheduler：运行进程</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#UART%EF%BC%9Atop"><span class="post-toc-text">UART：top</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%8E-shell-%E5%88%B0-uart"><span class="post-toc-text">从 shell 到 uart</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#stdin%E3%80%81stdout%E3%80%81stderr"><span class="post-toc-text">stdin、stdout、stderr</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#shell"><span class="post-toc-text">shell</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#filewrite"><span class="post-toc-text">filewrite</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#consolewrite"><span class="post-toc-text">consolewrite</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#uartputc"><span class="post-toc-text">uartputc</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#uartstart"><span class="post-toc-text">uartstart</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#UART%EF%BC%9Abottom"><span class="post-toc-text">UART：bottom</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A1%AC%E4%BB%B6%E9%83%A8%E5%88%86"><span class="post-toc-text">硬件部分</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#devintr-1"><span class="post-toc-text">devintr</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#uartintr%E3%80%81uartgetc%E3%80%81uartstart"><span class="post-toc-text">uartintr、uartgetc、uartstart</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Interrupt-%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="post-toc-text">Interrupt 与并发</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#producer-consumser%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%BB%A5uart%E4%B8%BA%E4%BE%8B"><span class="post-toc-text">producer&#x2F;consumser并发：以uart为例</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A2%AB%E4%B8%AD%E6%96%AD"><span class="post-toc-text">代码被中断</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#top-%E5%92%8C-bottom-%E5%B9%B6%E8%A1%8C%E8%BF%90%E8%A1%8C"><span class="post-toc-text">top 和 bottom 并行运行</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#UART%E8%AF%BB%E5%8F%96%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"><span class="post-toc-text">UART读取键盘输入</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%8E-fileread-%E5%88%B0-consoleintr"><span class="post-toc-text">从 fileread 到 consoleintr</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#consoleintr"><span class="post-toc-text">consoleintr</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%A7%A3%E8%80%A6"><span class="post-toc-text">解耦</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Interrupt%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="post-toc-text">Interrupt的演进</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%BE%E5%A4%87%E5%8F%98%E5%BE%97%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A4%8D%E6%9D%82"><span class="post-toc-text">设备变得越来越复杂</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Polling-vs-Interrupt"><span class="post-toc-text">Polling vs. Interrupt</span></a></li></ol></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="https://jsd.cdn.zzko.cn/npm/hexo-theme-a4@latest/source/css/lightgallery.min.css"><div class=".article-gallery"><h2 id="Interrupts-and-Device-Drivers"><a href="#Interrupts-and-Device-Drivers" class="headerlink" title="Interrupts and Device Drivers"></a>Interrupts and Device Drivers</h2><h3 id="课前准备"><a href="#课前准备" class="headerlink" title="课前准备"></a>课前准备</h3><p><code>驱动程序</code>用于管理特定设备，其行为包含：配置、指示操作、处理中断、与进程交互。它与设备是<code>并发</code>执行的，代码较为复杂；同时还必须理解硬件的设备接口</p>
<p>需要OS关注的硬件设备通常可以生成中断，内核识别 trap 并调用处理程序 <code>devintr</code> </p>
<blockquote>
<p>kernel&#x2F;trap.c：devintr</p>
</blockquote>
<p><code>驱动程序通常分为两部分</code>，一部分接收系统调用、对设备进行I&#x2F;O、让进程进行等待，另一部分确定哪个设备操作已经完成、并唤醒等待的进程、然后告诉硬件开始处理等待中的下一个操作</p>
<h4 id="Code-Console-input"><a href="#Code-Console-input" class="headerlink" title="Code: Console input"></a>Code: Console input</h4><p>console 控制程序连接到 <code>UART</code> 串行端口硬件接受人类输入的字符，一次接受一行，用户程序通过read读取这些字符</p>
<blockquote>
<p>The UART hardware that the driver talks to is a 16550 chip  emulated by QEMU. On a real computer, a 16550 would manage an RS232 serial link connecting to a terminal or other computer. When running QEMU, it’s connected to your keyboard and display.</p>
</blockquote>
<p>UART的内存映射地址从 <code>0x10000000</code> 开始，或者称为 UART0（kernel&#x2F;memlayout.h）。与它的交互<code>不通过内存</code>。</p>
<h5 id="UART：控制寄存器"><a href="#UART：控制寄存器" class="headerlink" title="UART：控制寄存器"></a>UART：控制寄存器</h5><p>UART 有少量的<code>控制寄存器</code>，每个寄存器长一个字节，其相对于UART0的偏移量在（kernel&#x2F;uart.c）中定义</p>
<ul>
<li><code>LSR</code>：line status register，是否有输入字符等待被软件读取</li>
<li><code>RHR</code>：receive holding register，用于读取字符。读取后UART会从其内部等待字符FIFO中删除它，读取所有等待字符后设置LSR为空</li>
<li><code>THR</code>：transmit holding register，软件写入字节</li>
</ul>
<p>UART <code>发送硬件与接收硬件基本独立</code></p>
<h5 id="consoleinit"><a href="#consoleinit" class="headerlink" title="consoleinit"></a>consoleinit</h5><p>Xv6的main函数调用consoleinit（kernel&#x2F;console.c）来初始化UART硬件。这段代码配置UART，以便在UART接收到每个输入字节时生成<code>接收中断</code>，并且每次UART完成发送一个输出字节时生成发送<code>完成中断</code></p>
<h5 id="shell-读取输入"><a href="#shell-读取输入" class="headerlink" title="shell 读取输入"></a>shell 读取输入</h5><p>xv6 shell通过init.c打开的 <code>文件描述符</code> 从控制台读取输入，对 <code>read</code> 的系统调用最终会通过内核传递到 <code>consoleread</code></p>
<p>consoleread 等待缓存在 <code>cons.buf</code> 中的输入到达（通过中断）后，将输入复制到用户空间，并在整个行到达后返回给用户进程。在输入一行完成前，任何读取的进程会在 <code>sleep</code> 中等待。</p>
<h5 id="devintr"><a href="#devintr" class="headerlink" title="devintr"></a>devintr</h5><p>当用户输入一个字符时，UART硬件会请求RISC-V触发中断，从而激活xv6的trap处理程序。</p>
<p>trap处理程序调用 <code>devintr</code>，该函数查看RISC-V的 <code>scause</code> 寄存器，发现中断来自外部设备。然后，它请求名为 <code>PLIC</code> 的硬件单元告知是哪台设备引发了中断。如果是UART，devintr会调用 <code>uartintr</code>。</p>
<h5 id="uartintr-与-consoleintr"><a href="#uartintr-与-consoleintr" class="headerlink" title="uartintr 与 consoleintr"></a>uartintr 与 consoleintr</h5><p>从UART硬件读取任何等待的输入字符并将其交给 <code>consoleintr</code>，<code>它不会等待字符</code>，因为未来的输入将触发新的中断。</p>
<p>consoleintr 将输入字符累积到 <code>cons.buf</code> 中，直到接收到完整的一行。它会特别处理退格键和其他一些字符。当收到换行符时，consoleintr 会唤醒正在等待的 <code>consoleread</code>，由它将其复制到用户空间，并返回到用户空间（通过系统调用机制）。</p>
<h4 id="Code-Console-output"><a href="#Code-Console-output" class="headerlink" title="Code: Console output"></a>Code: Console output</h4><p>连接到控制台的 <code>文件描述符</code> 上的 <code>write</code> 系统调用最终会到达 <code>uartputc</code> 函数。</p>
<h5 id="输出缓冲区与-uartputc"><a href="#输出缓冲区与-uartputc" class="headerlink" title="输出缓冲区与 uartputc"></a>输出缓冲区与 uartputc</h5><p>驱动程序维护了一个 <code>输出缓冲区</code>  uart_tx_buf，因此写入的进程 <code>不必等待</code> UART完成发送操作，由 <code>uartputc</code> 将每个字符附加到缓冲区，并调用 <code>uartstart</code> 启动设备传输。uartputc唯一等待的情况就是输出缓冲区满了</p>
<h5 id="完成中断与输出"><a href="#完成中断与输出" class="headerlink" title="完成中断与输出"></a>完成中断与输出</h5><p>每次UART完成发送一个字节时，它会生成一个中断。<code>uartintr</code> 会调用 <code>uartstart</code>，该函数会检查设备是否确实完成了发送，并将下一个缓冲的输出字符交给设备。</p>
<p>因此，如果一个进程向控制台写入多个字节，通常<code>第一个字节会由uartputc调用uartstart发送</code>，剩下的缓冲字节则由uartintr在接收到发送完成的中断后，通过调用uartstart发送。</p>
<h5 id="设备活动与进程活动的解耦"><a href="#设备活动与进程活动的解耦" class="headerlink" title="设备活动与进程活动的解耦"></a>设备活动与进程活动的解耦</h5><p>一般模式是通过 <code>缓冲和中断</code> 实现设备活动与进程活动的解耦：</p>
<ul>
<li><p>即使没有进程等待读取，控制台驱动程序也可以处理输入；后续的读取操作将获取到这些输入。</p>
</li>
<li><p>同样，进程可以发送输出而不必等待设备完成。这种解耦可以通过允许进程与设备I&#x2F;O并发执行来提高性能</p>
</li>
</ul>
<p>这在设备速度较慢（如UART）或需要立即响应（如回显输入字符）时尤为重要。这种思想有时被称为<code>I/O并发</code>。</p>
<h4 id="Concurrency-in-drivers"><a href="#Concurrency-in-drivers" class="headerlink" title="Concurrency in drivers"></a>Concurrency in drivers</h4><p>console 驱动程序的数据结构可能会受<code>并发访问</code>的影响</p>
<p>这里存在<code>三个并发风险</code>：两个位于不同CPU上的进程可能会同时调用consoleread；硬件可能会请求某个CPU在执行consoleread时处理控制台（实际上是UART）的中断；硬件还可能在consoleread执行时在不同的CPU上发出控制台中断。</p>
<p>并发需要在驱动程序中小心处理的另一个方面是，一个进程可能在等待设备输入，而表示输入到达的中断信号可能在另一个进程（或者没有进程运行时）到达。因此，<code>中断处理程序无法考虑它们中断的进程或代码</code>。例如，中断处理程序不能安全地使用当前进程的页表调用copyout。</p>
<p><code>中断处理程序通常执行相对较少的工作</code>（例如，仅将输入数据复制到缓冲区），并唤醒上半部分的代码来完成其余的工作。</p>
<h4 id="Timer-interrupts"><a href="#Timer-interrupts" class="headerlink" title="Timer interrupts"></a>Timer interrupts</h4><p>Xv6 使用定时器中断来维护其<code>时钟</code>，并进行进程切换；usertrap 和 kerneltrap 中的 <code>yield</code> 调用触发了这种切换。定时器中断来自连接到每个 RISC-V CPU 的<code>时钟硬件</code>。Xv6 将这些时钟硬件设置为定期中断每个 CPU。</p>
<h5 id="Timer-interrupts：机器模式"><a href="#Timer-interrupts：机器模式" class="headerlink" title="Timer interrupts：机器模式"></a>Timer interrupts：机器模式</h5><p>RISC-V 要求定时器中断必须在机器模式下处理，执行时<code>没有分页</code>，并且使用了一组<code>独立的控制寄存器</code>。在这种情况下，使用普通的 trap 机制是不现实的，需要 <code>单独处理</code></p>
<h5 id="main之前：start"><a href="#main之前：start" class="headerlink" title="main之前：start"></a>main之前：start</h5><p>在 main 函数之前，start.c 中的<code>机器模式代码设置了接收定时器中断的环境</code>（kernel&#x2F;start.c:57）。</p>
<p>这项工作的一部分是编程 CLINT 硬件（核心本地中断器），使其在一定延迟后生成中断。</p>
<p>另一部分是设置一个类似于 trapframe 的临时区域，以帮助定时器中断处理程序保存寄存器和 CLINT 寄存器的地址。最后，start 将 mtvec 设置为 timervec 并启用定时器中断。</p>
<h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p>可以在用户或内核代码执行的任何时候发生，<code>无法被禁用</code>。</p>
<p>所以定时器中断处理程序必须以保证不会扰乱原程序，基本策略是触发软件中断，并允许内核禁用这些软件中断</p>
<h5 id="timervec"><a href="#timervec" class="headerlink" title="timervec"></a>timervec</h5><blockquote>
<p>kernel&#x2F;kernelvec.S，汇编代码</p>
</blockquote>
<p>这是定时器中断的中断向量，它<code>在 start 准备的临时区域中保存了一些寄存器</code>，告诉 CLINT 何时生成下一次定时器中断，请求 RISC-V 触发软件中断，恢复寄存器并返回。</p>
<h4 id="Real-World"><a href="#Real-World" class="headerlink" title="Real World"></a>Real World</h4><h5 id="定时器带来的复杂性"><a href="#定时器带来的复杂性" class="headerlink" title="定时器带来的复杂性"></a>定时器带来的复杂性</h5><p>内核代码可能会由于定时器中断被挂起，然后在不同的CPU上恢复，这给Xv6带来了一些复杂性。如果设备和定时器中断只在执行用户代码时发生，内核可以变得稍微简单一些。</p>
<h5 id="驱动程序的繁重性"><a href="#驱动程序的繁重性" class="headerlink" title="驱动程序的繁重性"></a>驱动程序的繁重性</h5><p>支持典型计算机上的所有设备并充分利用其功能是一项繁重的工作，因为有许多设备，这些设备具有许多功能，并且设备与驱动程序之间的协议可能复杂且文档不足。在许多操作系统中，驱动程序的代码量超过了核心内核的代码量。</p>
<h5 id="程序化I-O-与-DMA"><a href="#程序化I-O-与-DMA" class="headerlink" title="程序化I&#x2F;O 与 DMA"></a>程序化I&#x2F;O 与 DMA</h5><p>UART驱动程序通过读取UART控制寄存器逐字节检索数据；这种模式被称为<code>程序化I/O</code>，因为数据的传输是由软件驱动的。</p>
<p>程序化I&#x2F;O简单，但在高速数据传输时太慢。需要高速传输大量数据的设备通常使用直接内存访问（<code>DMA</code>）。DMA设备硬件直接将传入数据写入RAM，并从RAM读取传出数据。现代磁盘和网络设备使用DMA。DMA设备的驱动程序会在RAM中准备数据，然后通过单次写入控制寄存器，告诉设备处理准备好的数据。</p>
<h5 id="批量中断"><a href="#批量中断" class="headerlink" title="批量中断"></a>批量中断</h5><p>当设备在不可预测的时间需要关注且频率不太高时，中断是合理的。但是中断会带来较高的CPU开销。因此，像网络和磁盘控制器这样的高速设备使用一些技巧来减少中断的需求。</p>
<p>一种技巧是<code>为一批传入或传出的请求触发单次中断</code>。另一种技巧是驱动程序完全禁用中断，定期检查设备是否需要关注。这种技术称为<code>轮询</code>。如果设备操作非常快，轮询是合理的，但如果设备大部分时间处于空闲状态，它会浪费CPU时间。</p>
<blockquote>
<p>一些驱动程序根据当前设备的负载动态地在轮询和中断之间切换。</p>
</blockquote>
<h5 id="UART-驱动程序的双重复制"><a href="#UART-驱动程序的双重复制" class="headerlink" title="UART 驱动程序的双重复制"></a>UART 驱动程序的双重复制</h5><p>UART驱动程序首先将传入数据复制到内核中的缓冲区，然后再复制到用户空间。这在低数据速率下是合理的，但这种双重复制会显著降低处理生成或消耗数据非常快的设备的性能。一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常使用DMA技术</p>
<h3 id="真实操作系统内存使用情况"><a href="#真实操作系统内存使用情况" class="headerlink" title="真实操作系统内存使用情况"></a>真实操作系统内存使用情况</h3><p>执行 <code>top</code>：</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240815160624.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240815160624.png" class title="Pasted image 20240815160624.png"></a>

<p>——<code>大部分内存都被用掉了</code>，其中很大一部分被用作 <code>buff/cache</code>，我们不想让物理内存闲置。这意味着如果需要新内存的话，必须撤回一些已有的内容</p>
<blockquote>
<p>RES：实际使用的内存数量，VIRT：虚拟内存地址空间的大小。可以看到RES远小于VIRT</p>
</blockquote>
<h3 id="Interrupt-硬件部分"><a href="#Interrupt-硬件部分" class="headerlink" title="Interrupt 硬件部分"></a>Interrupt 硬件部分</h3><h4 id="中断的特点"><a href="#中断的特点" class="headerlink" title="中断的特点"></a>中断的特点</h4><p>中断相比于其他的trap机制有一些不一样的地方：</p>
<ol>
<li><code>asynchronous</code>：Interrupt handler 不运行在任何特定进程的context中</li>
<li><code>concurrency</code>：外设和CPU是两个并行的设备</li>
<li><code>program device</code>：设备需要被编程才能使用。</li>
</ol>
<blockquote>
<p>设备的编程手册包含了它有什么样的寄存器，它能执行什么样的操作，在读写控制寄存器的时候，设备会如何响应。</p>
</blockquote>
<h4 id="中断从哪里产生？"><a href="#中断从哪里产生？" class="headerlink" title="中断从哪里产生？"></a>中断从哪里产生？</h4><p>主板上的各种线路将外设和CPU连接在一起，处理器通过Platform Level Interrupt Control，简称 <code>PLIC</code> 来处理设备中断。</p>
<h5 id="PLIC"><a href="#PLIC" class="headerlink" title="PLIC"></a>PLIC</h5><a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/image%2025.avif" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/image%2025.avif" class title="image 25.avif"></a>

<p>从左上角可以看出，我们有53个不同的来自于设备的中断。这些中断到达PLIC之后，PLIC会<code>路由</code>这些中断到某一个CPU的核。</p>
<p>如果所有的CPU核都正在处理中断，PLIC会保留中断直到有一个CPU核可以用来处理中断。所以PLIC需要保存一些内部数据来<code>跟踪中断的状态</code>。</p>
<h5 id="PLIC-中断处理流程"><a href="#PLIC-中断处理流程" class="headerlink" title="PLIC 中断处理流程"></a>PLIC 中断处理流程</h5><ul>
<li><p>PLIC会通知当前有一个待处理的中断</p>
</li>
<li><p>其中一个CPU核会Claim接收中断，这样PLIC就不会把中断发给其他的CPU处理</p>
</li>
<li><p>CPU核处理完中断之后，CPU会通知PLIC</p>
</li>
<li><p>PLIC将不再保存中断的信息</p>
</li>
</ul>
<p>PLIC只是分发中断，而内核需要<code>对PLIC进行编程</code>来告诉它中断应该分发到哪。实际上，内核可以对中断优先级进行编程，这里非常的灵活。</p>
<blockquote>
<p>例如对于xv6，这里的策略被编程为：所有的CPU都能收到中断，但是只有一个CPU会Claim相应的中断。</p>
</blockquote>
<h3 id="设备驱动概述"><a href="#设备驱动概述" class="headerlink" title="设备驱动概述"></a>设备驱动概述</h3><p>——管理外设的软件。我们今天要看的是UART设备的驱动</p>
<h4 id="驱动组成：bottom、top-与队列"><a href="#驱动组成：bottom、top-与队列" class="headerlink" title="驱动组成：bottom、top 与队列"></a>驱动组成：bottom、top 与队列</h4><p>大部分驱动都分为两个部分，<code>bottom/top</code>：</p>
<ul>
<li><p>bottom部分通常是 <code>Interrupt handler</code>。CPU接收中断后会调用这个处理程序。<code>不运行在任何特定进程的context中</code>，单纯处理中断。</p>
</li>
<li><p>top部分<code>与用户进程交互</code>，或者充当内核的其他部分调用的<code>接口</code></p>
</li>
</ul>
<p>通常来说会有一些<code>队列buffer</code>，bottom 和 top 都可以往其中读写数据，从而解耦设备与CPU：</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816152216.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816152216.png" class title="Pasted image 20240816152216.png"></a>


<h5 id="Interrupt-handler：限制"><a href="#Interrupt-handler：限制" class="headerlink" title="Interrupt handler：限制"></a>Interrupt handler：限制</h5><p>由于 Interrupt handler 不运行在任何特定上下文，也就没有适合的页表，<code>无法获取读写的地址</code>。top 部分与用户交互，并进行数据的读写</p>
<h4 id="对设备编程：memory-mapped-I-O"><a href="#对设备编程：memory-mapped-I-O" class="headerlink" title="对设备编程：memory mapped I&#x2F;O"></a>对设备编程：memory mapped I&#x2F;O</h4><p>通常来说，编程是通过 <code>memory mapped I/O</code> 完成的。即设备出现在特定的物理地址区间，OS只需要向这个地址区间进行读写即可完成对设备的编程。</p>
<blockquote>
<p>load&#x2F;store时实际上就是在读写<code>设备的控制寄存器</code>。物理地址区间位置由主板制造商决定。</p>
<p>你需要阅读设备的文档来弄清楚设备的寄存器和相应的行为。注意，这里是在直接操作设备，而不是通过RAM</p>
</blockquote>
<h5 id="SiFive主板"><a href="#SiFive主板" class="headerlink" title="SiFive主板"></a>SiFive主板</h5><p>例如，这是一个SiFive主板中的对应设备的物理地址，QEMU并没有完全模仿它：</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816155518.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816155518.png" class title="Pasted image 20240816155518.png"></a>


<h5 id="UART-文档"><a href="#UART-文档" class="headerlink" title="UART 文档"></a>UART 文档</h5><p>16550是QEMU模拟的UART设备，QEMU用这个模拟的设备来与键盘和Console进行交互。</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816155704.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816155704.png" class title="Pasted image 20240816155704.png"></a>

<ol>
<li>例如对于控制寄存器000，如果写它会将数据写入到寄存器中并被传输到其他地方，如果读它可以读出存储在寄存器中的内容。</li>
<li>例如控制寄存器001，可以通过它来控制UART是否产生中断。</li>
</ol>
<p>实际上<code>对于一个寄存器，其中的每个bit都有不同的作用</code>。例如对于寄存器001，也就是IER寄存器，bit0-bit3分别控制了不同的中断。</p>
<p><code>覆盖问题</code>：需要遵守一些协议，比如发送一个字节后需要等待中断提示完成发送才可以发送下一个字节，比如如果FIFO队列满了不能继续写入等待</p>
<h3 id="在XV6中设置中断"><a href="#在XV6中设置中断" class="headerlink" title="在XV6中设置中断"></a>在XV6中设置中断</h3><blockquote>
<p>当XV6启动时，Shell会输出提示符“$ ”，如果我们在键盘上输入ls，最终可以看到“$ ls”。我们接下来通过研究Console是如何显示出“$ ls”，来看一下设备中断是如何工作的。</p>
</blockquote>
<h4 id="中断寄存器"><a href="#中断寄存器" class="headerlink" title="中断寄存器"></a>中断寄存器</h4><p><code>每个CPU都有独立的一组控制寄存器</code></p>
<ul>
<li>stvec：指向trap第一步的汇编代码</li>
<li>scause：trap 原因</li>
<li>sstaus：外设中断开关 等</li>
<li><code>sie</code>：专门针对特定外设中断的开关。E：例如UART；S：软件中断；T：定时器中断</li>
<li><code>sip</code>：当前中断类型</li>
</ul>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816161521.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816161521.png" class title="Pasted image 20240816161521.png"></a>

<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816161502.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816161502.png" class title="Pasted image 20240816161502.png"></a>


<h4 id="xv6：配置中断"><a href="#xv6：配置中断" class="headerlink" title="xv6：配置中断"></a>xv6：配置中断</h4><h5 id="从-start-到-uartinit"><a href="#从-start-到-uartinit" class="headerlink" title="从 start 到 uartinit"></a>从 start 到 uartinit</h5><a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816163929.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816163929.png" class title="Pasted image 20240816163929.png"></a>

<p>这里将所有的中断都设置在<code>Supervisor mode</code>，然后<code>设置SIE</code>寄存器来接收External，软件和定时器中断，之后初始化定时器。再经过一些操作，跳转到了 main</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816164421.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816164421.png" class title="Pasted image 20240816164421.png"></a>

<p>首先初始化<code>console</code>，consoleinit 调用 uartinit 初始化了<code>uart</code></p>
<h5 id="uartinit：配置uart"><a href="#uartinit：配置uart" class="headerlink" title="uartinit：配置uart"></a>uartinit：配置uart</h5><p>这里关闭中断，设置串口传输速率 <code>baud rate</code>，设置字长为8bit，重置FIFO，打开中断</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816164505.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816164505.png" class title="Pasted image 20240816164505.png"></a>

<p>运行完这个函数后，uart 就可以生成中断了，但是<code>PLIC尚未被main初始化</code>，所以这个中断并不能被任何CPU接收。</p>
<h5 id="plicinit：配置PLIC"><a href="#plicinit：配置PLIC" class="headerlink" title="plicinit：配置PLIC"></a>plicinit：配置PLIC</h5><p><code>设置PLIC能接收哪些中断</code>。这里设置了接收UART与磁盘的中断</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816164847.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816164847.png" class title="Pasted image 20240816164847.png"></a>

<p>PLIC与外设一样，也占用了一个I&#x2F;O地址（<code>0xC000_0000</code>）</p>
<h5 id="plicinithart：配置CPU"><a href="#plicinithart：配置CPU" class="headerlink" title="plicinithart：配置CPU"></a>plicinithart：配置CPU</h5><p>plicinit之后就是plicinithart，它用于<code>设置CPU对哪些中断感兴趣</code>。plicinit是由0号CPU运行，每个CPU都需要调用plicinithart</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816165448.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816165448.png" class title="Pasted image 20240816165448.png"></a>

<p>此处我们忽略中断的优先级，所以将优先级设置为0。</p>
<h5 id="scheduler：运行进程"><a href="#scheduler：运行进程" class="headerlink" title="scheduler：运行进程"></a>scheduler：运行进程</h5><a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816165855.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816165855.png" class title="Pasted image 20240816165855.png"></a>

<p>实际运行进程前需要设置 <code>sstaus</code> 打开中断：</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816170125.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816170125.png" class title="Pasted image 20240816170125.png"></a>

<p>在这个时间点，如果PLIC有pending的中断，则CPU便会收到它</p>
<h3 id="UART：top"><a href="#UART：top" class="headerlink" title="UART：top"></a>UART：top</h3><h4 id="从-shell-到-uart"><a href="#从-shell-到-uart" class="headerlink" title="从 shell 到 uart"></a>从 shell 到 uart</h4><h5 id="stdin、stdout、stderr"><a href="#stdin、stdout、stderr" class="headerlink" title="stdin、stdout、stderr"></a>stdin、stdout、stderr</h5><blockquote>
<p>init.c：这是系统启动后运行的第一个用户进程。</p>
</blockquote>
<p>首先通过 <code>mknod</code> 创建了一个代表 console 的设备，其fd为0。然后复制这个文件描述符得到 <code>stdout</code> 和 <code>stderr</code>。也即，文件描述符012都表示console</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816174238.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816174238.png" class title="Pasted image 20240816174238.png"></a>

<p>然后fork一个子进程执行 <code>shell</code></p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816181056.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816181056.png" class title="Pasted image 20240816181056.png"></a>
<h5 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h5><p>shell 中不断获取一行命令：</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816181243.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816181243.png" class title="Pasted image 20240816181243.png"></a>

<blockquote>
<p>尽管Console背后是UART设备，但是从应用程序来看，它就像是一个普通的文件。Shell程序只是向文件描述符2写了数据，它并不知道文件描述符2对应的是什么。</p>
</blockquote>
<p>write 会走到系统调用 sys_write，sys_write检查参数后调用 <code>filewrite</code></p>
<h5 id="filewrite"><a href="#filewrite" class="headerlink" title="filewrite"></a>filewrite</h5><p>filewrite 先判断文件类型，对于 FD_DEVICE，会使用<code>设备特定的写函数</code>。这里是 <code>consolewrite</code></p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816185629.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816185629.png" class title="Pasted image 20240816185629.png"></a>

<h5 id="consolewrite"><a href="#consolewrite" class="headerlink" title="consolewrite"></a>consolewrite</h5><p>consolewrite 一个一个复制字符，并调用 <code>uartputc</code> 打印字符</p>
<blockquote>
<p>可以认为consolewrite是一个UART驱动的 <code>top</code> 部分。</p>
</blockquote>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816190138.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816190138.png" class title="Pasted image 20240816190138.png"></a>

<h5 id="uartputc"><a href="#uartputc" class="headerlink" title="uartputc"></a>uartputc</h5><p>uartputc 内部维护了一些数据结构：一个发送数据的<code>buf</code>，一个为consumer提供的<code>读指针</code>和为producer提供的<code>写指针</code>。从而构建了一个<code>环形的 buffer</code></p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816191121.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816191121.png" class title="Pasted image 20240816191121.png"></a>

<p>uartputc 首先检查 buf 是否满了，未满则写入一个字符，更新写指针</p>
<blockquote>
<p><code>w - r</code> 表示 buf 中已生产数据的个数，等于SIZE则已满。传统的方式会+1%size，这样操作的次数过多</p>
<p>wr 指针不断追逐，到达uint64上限直接溢出即可，仍然成立</p>
</blockquote>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816190613.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816190613.png" class title="Pasted image 20240816190613.png"></a>

<p>最后调用 uartstart</p>
<h5 id="uartstart"><a href="#uartstart" class="headerlink" title="uartstart"></a>uartstart</h5><p><code>通知设备执行操作</code>。循环地进行：</p>
<p>首先检查设备是否空闲，是则读取一个数据通过 <code>THR</code> 写给设备。</p>
<p>若LSR满了或缓冲区为空，则返回。循环中写入字符的同时，UART 可以并发地将LSR中的数据送出。</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816194012.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240816194012.png" class title="Pasted image 20240816194012.png"></a>


<h3 id="UART：bottom"><a href="#UART：bottom" class="headerlink" title="UART：bottom"></a>UART：bottom</h3><p>UART 发送完成后会产生一个中断</p>
<h4 id="硬件部分"><a href="#硬件部分" class="headerlink" title="硬件部分"></a>硬件部分</h4><p>PLIC将中断路由到一个CPU（<code>sstatus</code>的SIE开启），硬件会自动进行以下操作：</p>
<ul>
<li><code>清除SIE</code> bit以防止被再次中断</li>
<li><code>保存pc到sepc，记录被中断的mode</code></li>
<li><code>变为S-mode，设置pc为stvec的值</code>，准备跳转到uservec或kernelvec</li>
</ul>
<h4 id="devintr-1"><a href="#devintr-1" class="headerlink" title="devintr"></a>devintr</h4><p>如果被中断的是用户模式，经过 uservec 会跳转到 usertrap，然后会调用 <code>devintr</code>：</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817003855.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817003855.png" class title="Pasted image 20240817003855.png"></a>

<p>devintr 首先判断中断类型，对于外设中断，调用 <code>plic_claim</code> 获取中断号：</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817004659.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817004659.png" class title="Pasted image 20240817004659.png"></a>

<p>并根据中断类型调用相应的 <code>Interrupt handler</code>，此处为 uartintr：</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817004347.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817004347.png" class title="Pasted image 20240817004347.png"></a>

<h4 id="uartintr、uartgetc、uartstart"><a href="#uartintr、uartgetc、uartstart" class="headerlink" title="uartintr、uartgetc、uartstart"></a>uartintr、uartgetc、uartstart</h4><p><code>uartintr</code> 调用 <code>uartgetc</code> 从 uart 读取数据，若没有任何数据可以读取，则调用 <code>uartstart</code> 将buffer中的任意字符送出</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817010303.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817010303.png" class title="Pasted image 20240817010303.png"></a>

<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817010330.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817010330.png" class title="Pasted image 20240817010330.png"></a>

<p>UART 在发送 $ 的同时，CPU可以并发的将空格符写入 buffer，<code>所以在UART发送完成触发中断后，会发现缓冲区还有一个字符可以发送</code>，便会将这个空格送出</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817010553.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817010553.png" class title="Pasted image 20240817010553.png"></a>

<h3 id="Interrupt-与并发"><a href="#Interrupt-与并发" class="headerlink" title="Interrupt 与并发"></a>Interrupt 与并发</h3><p>这里的并发包括以下几个方面：</p>
<h4 id="producer-consumser并发：以uart为例"><a href="#producer-consumser并发：以uart为例" class="headerlink" title="producer&#x2F;consumser并发：以uart为例"></a>producer&#x2F;consumser并发：以uart为例</h4><p>设备与CPU是并行运行的，这里的并行称为 <code>producer-consumer并行</code>。</p>
<p>我们通过一个循环队列，一个读、一个写指针表示：</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/image%2026.avif" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/image%2026.avif" class title="image 26.avif"></a>

<ul>
<li>w&#x3D;r时，发送队列为空，handler 返回</li>
<li>uartputc 写入数据后，w+1。可以一直写直到队满</li>
<li>w-r&#x3D;size时，发送队列已满，producer必须停止运行，进程会被挂起</li>
<li>每当有中断触发 Interrupt handler，且发送队列不为空，uartintr 即会读取一个字符通过UART设备发送，r+1。可以一直发送直到队空</li>
<li>设备发送完毕数据后都会触发一个中断</li>
</ul>
<h4 id="代码被中断"><a href="#代码被中断" class="headerlink" title="代码被中断"></a>代码被中断</h4><p>中断会停止当前运行的程序，<code>包括内核代码</code>。有时内核代码需要关闭中断，以防止被打断</p>
<h4 id="top-和-bottom-并行运行"><a href="#top-和-bottom-并行运行" class="headerlink" title="top 和 bottom 并行运行"></a>top 和 bottom 并行运行</h4><p>驱动的 top 和 bottom 部分是并行运行的，可以<code>并行运行在不同的CPU上</code>。</p>
<p>这里我们通过 <code>lock</code> 来管理并行。因为这里有共享的数据，我们想要<code>buffer在一个时间只被一个CPU核所操作</code>。</p>
<p>一个设备只有一个buffer，但这个buffer被所有的CPU核共享</p>
<h3 id="UART读取键盘输入"><a href="#UART读取键盘输入" class="headerlink" title="UART读取键盘输入"></a>UART读取键盘输入</h3><p>在UART的另一侧，会有类似的事情发生，有时Shell会调用read从键盘中读取字符。</p>
<h4 id="从-fileread-到-consoleintr"><a href="#从-fileread-到-consoleintr" class="headerlink" title="从 fileread 到 consoleintr"></a>从 fileread 到 consoleintr</h4><p>read 底层会调用 <code>fileread</code>，若为设备，则 fileread <code>调用相应设备的 read 函数</code>，此处为 <code>consoleread</code></p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817013633.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817013633.png" class title="Pasted image 20240817013633.png"></a>

<p>consoleread 也有自己的buffer，但此时 <code>shell 变成了 consumer，而键盘是 producer</code></p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817013855.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817013855.png" class title="Pasted image 20240817013855.png"></a>

<p>当r&#x3D;w时buffer为空，shell进程sleep。当键盘产生输入并发送到UART，UART产生中断被PLIC路由到一个CPU核，然后由trap机制进入devintr，调用 uartintr。</p>
<p>uartintr 通过 <code>uartgetc</code> 获取到字符，然后传递给 <code>consoleintr</code></p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817014332.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817014332.png" class title="Pasted image 20240817014332.png"></a>

<h4 id="consoleintr"><a href="#consoleintr" class="headerlink" title="consoleintr"></a>consoleintr</h4><p>对于输入的字符，consoleintr 在默认情形下会通过 <code>consputc</code> 将它输出到 console，之后，字符被存放在buffer中。遇到换行符则唤醒之前挂起的进程，将数据全部读出</p>
<a href="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817014941.png" class="gallery-item" style="box-shadow: none;"> <img src="/2024/08/17/6.s081%20lec9%20Interrupts%20and%20Device%20Drivers/Pasted%20image%2020240817014941.png" class title="Pasted image 20240817014941.png"></a>


<h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><p>所以这里也是通过buffer将consumer和producer之间解耦，这样它们才能按照自己的速度，独立的并行运行。</p>
<p>如果某一个运行的过快了，那么buffer要么是满的要么是空的，consumer和producer其中一个会sleep并等待另一个追上来。</p>
<h3 id="Interrupt的演进"><a href="#Interrupt的演进" class="headerlink" title="Interrupt的演进"></a>Interrupt的演进</h3><h4 id="设备变得越来越复杂"><a href="#设备变得越来越复杂" class="headerlink" title="设备变得越来越复杂"></a>设备变得越来越复杂</h4><p>CPU需要很多步骤才能真正的处理中断数据，所以在产生中断之前，<code>设备上会执行大量的操作</code>，这样可以减轻CPU的处理负担。这使得现在硬件变得更加复杂。</p>
<h4 id="Polling-vs-Interrupt"><a href="#Polling-vs-Interrupt" class="headerlink" title="Polling vs. Interrupt"></a>Polling vs. Interrupt</h4><p>对于一个高速产生中断的设备，比如千兆网卡，CPU难以处理巨量的中断。这里的解决方法就是使用 <code>polling</code></p>
<p>除了依赖 Interrupt，CPU可以一直读取外设的控制寄存器，来检查是否有数据。</p>
<p>这种方法浪费了CPU cycles，不能执行任何其他的操作。但对于处理高速设备的中断而言，这种轮询是完全值得的，它降低了大量中断产生的代价</p>
</div><script src="https://jsd.cdn.zzko.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if("undefined"!=typeof lightGallery) {
        var options1 = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1);
        }</script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-08-17</span>
            
                <span>该篇文章被 Toki</span>
            
            
             
                <span>归为分类:
                    
                    
                        <a href='/categories/6-s081/'>
                            6.s081
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 2024 

            
                

            
                
                    / <a href="/contact/"> 联系 </a>
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>